import * as domain from "domain";
import { NodeClient } from "./client.js";
import { Console } from "./integrations/console.js";
import { Http } from "./integrations/http.js";
import { OnUncaughtException } from "./integrations/onuncaughtexception.js";
import { OnUnhandledRejection } from "./integrations/onunhandledrejection.js";
import { LinkedErrors } from "./integrations/linkederrors.js";
import { Modules } from "./integrations/modules.js";
import { ContextLines } from "./integrations/contextlines.js";
import { Context } from "./integrations/context.js";
import { RequestData } from "./integrations/requestdata.js";
import { LocalVariables } from "./integrations/localvariables.js";
import { getModule } from "./module.js";
import { makeNodeTransport } from "./transports/http.js";
import { createStackParser, stackParserFromStackParserOptions, nodeStackLineParser } from "../../utils/esm/stacktrace.js";
import { getMainCarrier, setHubOnCarrier, getCurrentHub } from "../../core/esm/hub.js";
import { _optionalChain } from "../../utils/esm/buildPolyfills/_optionalChain.js";
import { getIntegrationsToSetup } from "../../core/esm/integration.js";
import { initAndBind } from "../../core/esm/sdk.js";
import { GLOBAL_OBJ } from "../../utils/esm/worldwide.js";
import { InboundFilters } from "../../core/esm/integrations/inboundfilters.js";
import { FunctionToString } from "../../core/esm/integrations/functiontostring.js";
const defaultIntegrations = [
  // Common
  new InboundFilters(),
  new FunctionToString(),
  // Native Wrappers
  new Console(),
  new Http(),
  // Global Handlers
  new OnUncaughtException(),
  new OnUnhandledRejection(),
  // Event Info
  new ContextLines(),
  new LocalVariables(),
  new Context(),
  new Modules(),
  new RequestData(),
  // Misc
  new LinkedErrors()
];
function init(options = {}) {
  const carrier = getMainCarrier();
  const autoloadedIntegrations = _optionalChain([carrier, "access", (_) => _.__SENTRY__, "optionalAccess", (_2) => _2.integrations]) || [];
  options.defaultIntegrations = options.defaultIntegrations === false ? [] : [
    ...Array.isArray(options.defaultIntegrations) ? options.defaultIntegrations : defaultIntegrations,
    ...autoloadedIntegrations
  ];
  if (options.dsn === void 0 && process.env.SENTRY_DSN) {
    options.dsn = process.env.SENTRY_DSN;
  }
  if (options.tracesSampleRate === void 0 && process.env.SENTRY_TRACES_SAMPLE_RATE) {
    const tracesSampleRate = parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE);
    if (isFinite(tracesSampleRate)) {
      options.tracesSampleRate = tracesSampleRate;
    }
  }
  if (options.release === void 0) {
    const detectedRelease = getSentryRelease();
    if (detectedRelease !== void 0) {
      options.release = detectedRelease;
    } else {
      options.autoSessionTracking = false;
    }
  }
  if (options.environment === void 0 && process.env.SENTRY_ENVIRONMENT) {
    options.environment = process.env.SENTRY_ENVIRONMENT;
  }
  if (options.autoSessionTracking === void 0 && options.dsn !== void 0) {
    options.autoSessionTracking = true;
  }
  if (options.instrumenter === void 0) {
    options.instrumenter = "sentry";
  }
  if (domain.active) {
    setHubOnCarrier(carrier, getCurrentHub());
  }
  const clientOptions = {
    ...options,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup(options),
    transport: options.transport || makeNodeTransport
  };
  initAndBind(NodeClient, clientOptions);
  if (options.autoSessionTracking) {
    startSessionTracking();
  }
}
function getSentryRelease(fallback) {
  if (process.env.SENTRY_RELEASE) {
    return process.env.SENTRY_RELEASE;
  }
  if (GLOBAL_OBJ.SENTRY_RELEASE && GLOBAL_OBJ.SENTRY_RELEASE.id) {
    return GLOBAL_OBJ.SENTRY_RELEASE.id;
  }
  return (
    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables
    process.env.GITHUB_SHA || // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata
    process.env.COMMIT_REF || // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables
    process.env.VERCEL_GIT_COMMIT_SHA || process.env.VERCEL_GITHUB_COMMIT_SHA || process.env.VERCEL_GITLAB_COMMIT_SHA || process.env.VERCEL_BITBUCKET_COMMIT_SHA || // Zeit (now known as Vercel)
    process.env.ZEIT_GITHUB_COMMIT_SHA || process.env.ZEIT_GITLAB_COMMIT_SHA || process.env.ZEIT_BITBUCKET_COMMIT_SHA || fallback
  );
}
const defaultStackParser = createStackParser(nodeStackLineParser(getModule));
function startSessionTracking() {
  const hub = getCurrentHub();
  hub.startSession();
  process.on("beforeExit", () => {
    const session = _optionalChain([hub, "access", (_3) => _3.getScope, "call", (_4) => _4(), "optionalAccess", (_5) => _5.getSession, "call", (_6) => _6()]);
    const terminalStates = ["exited", "crashed"];
    if (session && !terminalStates.includes(session.status))
      hub.endSession();
  });
}
export {
  defaultIntegrations,
  defaultStackParser,
  getSentryRelease,
  init
};
//# sourceMappingURL=sdk.js.map
