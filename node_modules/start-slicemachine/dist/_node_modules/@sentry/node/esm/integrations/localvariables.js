import "../../../../lru_map/lru.js";
import { __exports as lru } from "../../../../../_virtual/lru.js";
import { _optionalChain } from "../../../utils/esm/buildPolyfills/_optionalChain.js";
class AsyncSession {
  /** Throws is inspector API is not available */
  constructor() {
    const { Session } = require("inspector");
    this._session = new Session();
  }
  /** @inheritdoc */
  configureAndConnect(onPause, captureAll) {
    this._session.connect();
    this._session.on("Debugger.paused", onPause);
    this._session.post("Debugger.enable");
    this._session.post("Debugger.setPauseOnExceptions", { state: captureAll ? "all" : "uncaught" });
  }
  /** @inheritdoc */
  async getLocalVariables(objectId) {
    const props = await this._getProperties(objectId);
    const unrolled = {};
    for (const prop of props) {
      if (_optionalChain([prop, "optionalAccess", (_) => _.value, "optionalAccess", (_2) => _2.objectId]) && _optionalChain([prop, "optionalAccess", (_3) => _3.value, "access", (_4) => _4.className]) === "Array") {
        unrolled[prop.name] = await this._unrollArray(prop.value.objectId);
      } else if (_optionalChain([prop, "optionalAccess", (_5) => _5.value, "optionalAccess", (_6) => _6.objectId]) && _optionalChain([prop, "optionalAccess", (_7) => _7.value, "optionalAccess", (_8) => _8.className]) === "Object") {
        unrolled[prop.name] = await this._unrollObject(prop.value.objectId);
      } else if (_optionalChain([prop, "optionalAccess", (_9) => _9.value, "optionalAccess", (_10) => _10.value]) || _optionalChain([prop, "optionalAccess", (_11) => _11.value, "optionalAccess", (_12) => _12.description])) {
        unrolled[prop.name] = prop.value.value || `<${prop.value.description}>`;
      }
    }
    return unrolled;
  }
  /**
   * Gets all the PropertyDescriptors of an object
   */
  _getProperties(objectId) {
    return new Promise((resolve, reject) => {
      this._session.post(
        "Runtime.getProperties",
        {
          objectId,
          ownProperties: true
        },
        (err, params) => {
          if (err) {
            reject(err);
          } else {
            resolve(params.result);
          }
        }
      );
    });
  }
  /**
   * Unrolls an array property
   */
  async _unrollArray(objectId) {
    const props = await this._getProperties(objectId);
    return props.filter((v) => v.name !== "length" && !isNaN(parseInt(v.name, 10))).sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10)).map((v) => _optionalChain([v, "optionalAccess", (_13) => _13.value, "optionalAccess", (_14) => _14.value]));
  }
  /**
   * Unrolls an object property
   */
  async _unrollObject(objectId) {
    const props = await this._getProperties(objectId);
    return props.map((v) => [v.name, _optionalChain([v, "optionalAccess", (_15) => _15.value, "optionalAccess", (_16) => _16.value])]).reduce((obj, [key, val]) => {
      obj[key] = val;
      return obj;
    }, {});
  }
}
function tryNewAsyncSession() {
  try {
    return new AsyncSession();
  } catch (e) {
    return void 0;
  }
}
function isAnonymous(name) {
  return name !== void 0 && ["", "?", "<anonymous>"].includes(name);
}
function functionNamesMatch(a, b) {
  return a === b || isAnonymous(a) && isAnonymous(b);
}
function hashFrames(frames) {
  if (frames === void 0) {
    return;
  }
  return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, "");
}
function hashFromStack(stackParser, stack) {
  if (stack === void 0) {
    return void 0;
  }
  return hashFrames(stackParser(stack, 1));
}
class LocalVariables {
  static __initStatic() {
    this.id = "LocalVariables";
  }
  __init() {
    this.name = LocalVariables.id;
  }
  __init2() {
    this._cachedFrames = new lru.LRUMap(20);
  }
  constructor(_options = {}, _session = tryNewAsyncSession()) {
    this._options = _options;
    this._session = _session;
    LocalVariables.prototype.__init.call(this);
    LocalVariables.prototype.__init2.call(this);
  }
  /**
   * @inheritDoc
   */
  setupOnce(addGlobalEventProcessor, getCurrentHub) {
    this._setup(addGlobalEventProcessor, _optionalChain([getCurrentHub, "call", (_17) => _17(), "access", (_18) => _18.getClient, "call", (_19) => _19(), "optionalAccess", (_20) => _20.getOptions, "call", (_21) => _21()]));
  }
  /** Setup in a way that's easier to call from tests */
  _setup(addGlobalEventProcessor, clientOptions) {
    if (this._session && _optionalChain([clientOptions, "optionalAccess", (_22) => _22.includeLocalVariables])) {
      this._session.configureAndConnect(
        (ev) => this._handlePaused(clientOptions.stackParser, ev),
        !!this._options.captureAllExceptions
      );
      addGlobalEventProcessor(async (event) => this._addLocalVariables(event));
    }
  }
  /**
   * Handle the pause event
   */
  async _handlePaused(stackParser, { params: { reason, data, callFrames } }) {
    if (reason !== "exception" && reason !== "promiseRejection") {
      return;
    }
    const exceptionHash = hashFromStack(stackParser, _optionalChain([data, "optionalAccess", (_23) => _23.description]));
    if (exceptionHash == void 0) {
      return;
    }
    const framePromises = callFrames.map(async ({ scopeChain, functionName, this: obj }) => {
      const localScope = scopeChain.find((scope) => scope.type === "local");
      const fn = obj.className === "global" || !obj.className ? functionName : `${obj.className}.${functionName}`;
      if (_optionalChain([localScope, "optionalAccess", (_24) => _24.object, "access", (_25) => _25.objectId]) === void 0) {
        return { function: fn };
      }
      const vars = await _optionalChain([this, "access", (_26) => _26._session, "optionalAccess", (_27) => _27.getLocalVariables, "call", (_28) => _28(localScope.object.objectId)]);
      return { function: fn, vars };
    });
    this._cachedFrames.set(exceptionHash, Promise.all(framePromises));
  }
  /**
   * Adds local variables event stack frames.
   */
  async _addLocalVariables(event) {
    for (const exception of _optionalChain([event, "optionalAccess", (_29) => _29.exception, "optionalAccess", (_30) => _30.values]) || []) {
      await this._addLocalVariablesToException(exception);
    }
    return event;
  }
  /**
   * Adds local variables to the exception stack frames.
   */
  async _addLocalVariablesToException(exception) {
    const hash = hashFrames(_optionalChain([exception, "optionalAccess", (_31) => _31.stacktrace, "optionalAccess", (_32) => _32.frames]));
    if (hash === void 0) {
      return;
    }
    const cachedFrames = await this._cachedFrames.delete(hash);
    if (cachedFrames === void 0) {
      return;
    }
    const frameCount = _optionalChain([exception, "access", (_33) => _33.stacktrace, "optionalAccess", (_34) => _34.frames, "optionalAccess", (_35) => _35.length]) || 0;
    for (let i = 0; i < frameCount; i++) {
      const frameIndex = frameCount - i - 1;
      if (!_optionalChain([exception, "optionalAccess", (_36) => _36.stacktrace, "optionalAccess", (_37) => _37.frames, "optionalAccess", (_38) => _38[frameIndex]]) || !cachedFrames[i]) {
        break;
      }
      if (
        // We need to have vars to add
        cachedFrames[i].vars === void 0 || // We're not interested in frames that are not in_app because the vars are not relevant
        exception.stacktrace.frames[frameIndex].in_app === false || // The function names need to match
        !functionNamesMatch(exception.stacktrace.frames[frameIndex].function, cachedFrames[i].function)
      ) {
        continue;
      }
      exception.stacktrace.frames[frameIndex].vars = cachedFrames[i].vars;
    }
  }
}
LocalVariables.__initStatic();
export {
  LocalVariables
};
//# sourceMappingURL=localvariables.js.map
