import "../../../../lru_map/lru.js";
import { normalizeRequestArgs, extractUrl, isSentryRequest, cleanSpanDescription } from "./utils/http.js";
import { parseSemver } from "../../../utils/esm/misc.js";
import { _optionalChain } from "../../../utils/esm/buildPolyfills/_optionalChain.js";
import { logger } from "../../../utils/esm/logger.js";
import { fill } from "../../../utils/esm/object.js";
import { __exports as lru } from "../../../../../_virtual/lru.js";
import { getCurrentHub } from "../../../core/esm/hub.js";
import { dynamicSamplingContextToSentryBaggageHeader } from "../../../utils/esm/baggage.js";
import { stringMatchesSomePattern } from "../../../utils/esm/string.js";
const NODE_VERSION = parseSemver(process.versions.node);
class Http {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Http";
  }
  /**
   * @inheritDoc
   */
  __init() {
    this.name = Http.id;
  }
  /**
   * @inheritDoc
   */
  constructor(options = {}) {
    Http.prototype.__init.call(this);
    this._breadcrumbs = typeof options.breadcrumbs === "undefined" ? true : options.breadcrumbs;
    this._tracing = !options.tracing ? void 0 : options.tracing === true ? {} : options.tracing;
  }
  /**
   * @inheritDoc
   */
  setupOnce(_addGlobalEventProcessor, setupOnceGetCurrentHub) {
    if (!this._breadcrumbs && !this._tracing) {
      return;
    }
    const clientOptions = _optionalChain([setupOnceGetCurrentHub, "call", (_) => _(), "access", (_2) => _2.getClient, "call", (_3) => _3(), "optionalAccess", (_4) => _4.getOptions, "call", (_5) => _5()]);
    if (clientOptions && clientOptions.instrumenter !== "sentry") {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log("HTTP Integration is skipped because of instrumenter configuration.");
      return;
    }
    const tracingOptions = this._tracing ? { ...clientOptions, ...this._tracing } : void 0;
    const httpModule = require("http");
    const wrappedHttpHandlerMaker = _createWrappedRequestMethodFactory(this._breadcrumbs, tracingOptions, httpModule);
    fill(httpModule, "get", wrappedHttpHandlerMaker);
    fill(httpModule, "request", wrappedHttpHandlerMaker);
    if (NODE_VERSION.major && NODE_VERSION.major > 8) {
      const httpsModule = require("https");
      const wrappedHttpsHandlerMaker = _createWrappedRequestMethodFactory(
        this._breadcrumbs,
        tracingOptions,
        httpsModule
      );
      fill(httpsModule, "get", wrappedHttpsHandlerMaker);
      fill(httpsModule, "request", wrappedHttpsHandlerMaker);
    }
  }
}
Http.__initStatic();
function _createWrappedRequestMethodFactory(breadcrumbsEnabled, tracingOptions, httpModule) {
  const createSpanUrlMap = new lru.LRUMap(100);
  const headersUrlMap = {};
  const shouldCreateSpan = (url) => {
    if (_optionalChain([tracingOptions, "optionalAccess", (_6) => _6.shouldCreateSpanForRequest]) === void 0) {
      return true;
    }
    const cachedDecision = createSpanUrlMap.get(url);
    if (cachedDecision !== void 0) {
      return cachedDecision;
    }
    const decision = tracingOptions.shouldCreateSpanForRequest(url);
    createSpanUrlMap.set(url, decision);
    return decision;
  };
  const shouldAttachTraceData = (url) => {
    if (_optionalChain([tracingOptions, "optionalAccess", (_7) => _7.tracePropagationTargets]) === void 0) {
      return true;
    }
    if (headersUrlMap[url]) {
      return headersUrlMap[url];
    }
    headersUrlMap[url] = stringMatchesSomePattern(url, tracingOptions.tracePropagationTargets);
    return headersUrlMap[url];
  };
  return function wrappedRequestMethodFactory(originalRequestMethod) {
    return function wrappedMethod(...args) {
      const requestArgs = normalizeRequestArgs(httpModule, args);
      const requestOptions = requestArgs[0];
      const requestUrl = extractUrl(requestOptions);
      if (isSentryRequest(requestUrl)) {
        return originalRequestMethod.apply(httpModule, requestArgs);
      }
      let requestSpan;
      let parentSpan;
      const scope = getCurrentHub().getScope();
      if (scope && tracingOptions && shouldCreateSpan(requestUrl)) {
        parentSpan = scope.getSpan();
        if (parentSpan) {
          requestSpan = parentSpan.startChild({
            description: `${requestOptions.method || "GET"} ${requestUrl}`,
            op: "http.client"
          });
          if (shouldAttachTraceData(requestUrl)) {
            const sentryTraceHeader = requestSpan.toTraceparent();
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(
              `[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to "${requestUrl}": `
            );
            requestOptions.headers = {
              ...requestOptions.headers,
              "sentry-trace": sentryTraceHeader
            };
            if (parentSpan.transaction) {
              const dynamicSamplingContext = parentSpan.transaction.getDynamicSamplingContext();
              const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);
              let newBaggageHeaderField;
              if (!requestOptions.headers || !requestOptions.headers.baggage) {
                newBaggageHeaderField = sentryBaggageHeader;
              } else if (!sentryBaggageHeader) {
                newBaggageHeaderField = requestOptions.headers.baggage;
              } else if (Array.isArray(requestOptions.headers.baggage)) {
                newBaggageHeaderField = [...requestOptions.headers.baggage, sentryBaggageHeader];
              } else {
                newBaggageHeaderField = [requestOptions.headers.baggage, sentryBaggageHeader];
              }
              requestOptions.headers = {
                ...requestOptions.headers,
                // Setting a hader to `undefined` will crash in node so we only set the baggage header when it's defined
                ...newBaggageHeaderField && { baggage: newBaggageHeaderField }
              };
            }
          } else {
            (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.log(
              `[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`
            );
          }
        }
      }
      return originalRequestMethod.apply(httpModule, requestArgs).once("response", function(res) {
        const req = this;
        if (breadcrumbsEnabled) {
          addRequestBreadcrumb("response", requestUrl, req, res);
        }
        if (requestSpan) {
          if (res.statusCode) {
            requestSpan.setHttpStatus(res.statusCode);
          }
          requestSpan.description = cleanSpanDescription(requestSpan.description, requestOptions, req);
          requestSpan.finish();
        }
      }).once("error", function() {
        const req = this;
        if (breadcrumbsEnabled) {
          addRequestBreadcrumb("error", requestUrl, req);
        }
        if (requestSpan) {
          requestSpan.setHttpStatus(500);
          requestSpan.description = cleanSpanDescription(requestSpan.description, requestOptions, req);
          requestSpan.finish();
        }
      });
    };
  };
}
function addRequestBreadcrumb(event, url, req, res) {
  if (!getCurrentHub().getIntegration(Http)) {
    return;
  }
  getCurrentHub().addBreadcrumb(
    {
      category: "http",
      data: {
        method: req.method,
        status_code: res && res.statusCode,
        url
      },
      type: "http"
    },
    {
      event,
      request: req,
      response: res
    }
  );
}
export {
  Http
};
//# sourceMappingURL=http.js.map
