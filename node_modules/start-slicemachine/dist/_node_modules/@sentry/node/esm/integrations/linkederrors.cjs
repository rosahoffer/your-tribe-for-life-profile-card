"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const eventbuilder = require("../eventbuilder.cjs");
const contextlines = require("./contextlines.cjs");
const scope = require("../../../core/esm/scope.cjs");
const is = require("../../../utils/esm/is.cjs");
const syncpromise = require("../../../utils/esm/syncpromise.cjs");
const hub = require("../../../core/esm/hub.cjs");
const _optionalChain = require("../../../utils/esm/buildPolyfills/_optionalChain.cjs");
const DEFAULT_KEY = "cause";
const DEFAULT_LIMIT = 5;
class LinkedErrors {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "LinkedErrors";
  }
  /**
   * @inheritDoc
   */
  __init() {
    this.name = LinkedErrors.id;
  }
  /**
   * @inheritDoc
   */
  /**
   * @inheritDoc
   */
  /**
   * @inheritDoc
   */
  constructor(options = {}) {
    LinkedErrors.prototype.__init.call(this);
    this._key = options.key || DEFAULT_KEY;
    this._limit = options.limit || DEFAULT_LIMIT;
  }
  /**
   * @inheritDoc
   */
  setupOnce() {
    scope.addGlobalEventProcessor(async (event, hint) => {
      const hub$1 = hub.getCurrentHub();
      const self = hub$1.getIntegration(LinkedErrors);
      const client = hub$1.getClient();
      if (client && self && self._handler && typeof self._handler === "function") {
        await self._handler(client.getOptions().stackParser, event, hint);
      }
      return event;
    });
  }
  /**
   * @inheritDoc
   */
  _handler(stackParser, event, hint) {
    if (!event.exception || !event.exception.values || !is.isInstanceOf(hint.originalException, Error)) {
      return syncpromise.resolvedSyncPromise(event);
    }
    return new syncpromise.SyncPromise((resolve) => {
      void this._walkErrorTree(stackParser, hint.originalException, this._key).then((linkedErrors) => {
        if (event && event.exception && event.exception.values) {
          event.exception.values = [...linkedErrors, ...event.exception.values];
        }
        resolve(event);
      }).then(null, () => {
        resolve(event);
      });
    });
  }
  /**
   * @inheritDoc
   */
  async _walkErrorTree(stackParser, error, key, stack = []) {
    if (!is.isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {
      return Promise.resolve(stack);
    }
    const exception = eventbuilder.exceptionFromError(stackParser, error[key]);
    const contextLines = hub.getCurrentHub().getIntegration(contextlines.ContextLines);
    if (contextLines && _optionalChain._optionalChain([exception, "access", (_) => _.stacktrace, "optionalAccess", (_2) => _2.frames])) {
      await contextLines.addSourceContextToFrames(exception.stacktrace.frames);
    }
    return new Promise((resolve, reject) => {
      void this._walkErrorTree(stackParser, error[key], key, [exception, ...stack]).then(resolve).then(null, () => {
        reject();
      });
    });
  }
}
LinkedErrors.__initStatic();
exports.LinkedErrors = LinkedErrors;
//# sourceMappingURL=linkederrors.cjs.map
