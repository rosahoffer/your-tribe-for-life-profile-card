"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const os = require("os");
const util = require("util");
const eventbuilder = require("./eventbuilder.cjs");
const baseclient = require("../../core/esm/baseclient.cjs");
const version = require("../../core/esm/version.cjs");
const _optionalChain = require("../../utils/esm/buildPolyfills/_optionalChain.cjs");
const logger = require("../../utils/esm/logger.cjs");
const sessionflusher = require("../../core/esm/sessionflusher.cjs");
const syncpromise = require("../../utils/esm/syncpromise.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const os__namespace = /* @__PURE__ */ _interopNamespaceDefault(os);
class NodeClient extends baseclient.BaseClient {
  /**
   * Creates a new Node SDK instance.
   * @param options Configuration options for this SDK.
   */
  constructor(options) {
    options._metadata = options._metadata || {};
    options._metadata.sdk = options._metadata.sdk || {
      name: "sentry.javascript.node",
      packages: [
        {
          name: "npm:@sentry/node",
          version: version.SDK_VERSION
        }
      ],
      version: version.SDK_VERSION
    };
    options.transportOptions = {
      textEncoder: new util.TextEncoder(),
      ...options.transportOptions
    };
    super(options);
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  captureException(exception, hint, scope) {
    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
      const requestSession = scope.getRequestSession();
      if (requestSession && requestSession.status === "ok") {
        requestSession.status = "errored";
      }
    }
    return super.captureException(exception, hint, scope);
  }
  /**
   * @inheritDoc
   */
  captureEvent(event, hint, scope) {
    if (this._options.autoSessionTracking && this._sessionFlusher && scope) {
      const eventType = event.type || "exception";
      const isException = eventType === "exception" && event.exception && event.exception.values && event.exception.values.length > 0;
      if (isException) {
        const requestSession = scope.getRequestSession();
        if (requestSession && requestSession.status === "ok") {
          requestSession.status = "errored";
        }
      }
    }
    return super.captureEvent(event, hint, scope);
  }
  /**
   *
   * @inheritdoc
   */
  close(timeout) {
    _optionalChain._optionalChain([this, "access", (_) => _._sessionFlusher, "optionalAccess", (_2) => _2.close, "call", (_3) => _3()]);
    return super.close(timeout);
  }
  /** Method that initialises an instance of SessionFlusher on Client */
  initSessionFlusher() {
    const { release, environment } = this._options;
    if (!release) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.logger.warn("Cannot initialise an instance of SessionFlusher if no release is provided!");
    } else {
      this._sessionFlusher = new sessionflusher.SessionFlusher(this, {
        release,
        environment
      });
    }
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  eventFromException(exception, hint) {
    return syncpromise.resolvedSyncPromise(eventbuilder.eventFromUnknownInput(this._options.stackParser, exception, hint));
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(message, level = "info", hint) {
    return syncpromise.resolvedSyncPromise(
      eventbuilder.eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace)
    );
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(event, hint, scope) {
    event.platform = event.platform || "node";
    event.contexts = {
      ...event.contexts,
      runtime: _optionalChain._optionalChain([event, "access", (_4) => _4.contexts, "optionalAccess", (_5) => _5.runtime]) || {
        name: "node",
        version: global.process.version
      }
    };
    event.server_name = event.server_name || this.getOptions().serverName || global.process.env.SENTRY_NAME || os__namespace.hostname();
    return super._prepareEvent(event, hint, scope);
  }
  /**
   * Method responsible for capturing/ending a request session by calling `incrementSessionStatusCount` to increment
   * appropriate session aggregates bucket
   */
  _captureRequestSession() {
    if (!this._sessionFlusher) {
      (typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__) && logger.logger.warn("Discarded request mode session because autoSessionTracking option was disabled");
    } else {
      this._sessionFlusher.incrementSessionStatusCount();
    }
  }
}
exports.NodeClient = NodeClient;
//# sourceMappingURL=client.cjs.map
