"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const is = require("../../utils/esm/is.cjs");
const object = require("../../utils/esm/object.cjs");
const hub = require("../../core/esm/hub.cjs");
const normalize = require("../../utils/esm/normalize.cjs");
const misc = require("../../utils/esm/misc.cjs");
function parseStackFrames(stackParser, error) {
  return stackParser(error.stack || "", 1);
}
function exceptionFromError(stackParser, error) {
  const exception = {
    type: error.name || error.constructor.name,
    value: error.message
  };
  const frames = parseStackFrames(stackParser, error);
  if (frames.length) {
    exception.stacktrace = { frames };
  }
  return exception;
}
function eventFromUnknownInput(stackParser, exception, hint) {
  let ex = exception;
  const providedMechanism = hint && hint.data && hint.data.mechanism;
  const mechanism = providedMechanism || {
    handled: true,
    type: "generic"
  };
  if (!is.isError(exception)) {
    if (is.isPlainObject(exception)) {
      const message = `Non-Error exception captured with keys: ${object.extractExceptionKeysForMessage(exception)}`;
      const hub$1 = hub.getCurrentHub();
      const client = hub$1.getClient();
      const normalizeDepth = client && client.getOptions().normalizeDepth;
      hub$1.configureScope((scope) => {
        scope.setExtra("__serialized__", normalize.normalizeToSize(exception, normalizeDepth));
      });
      ex = hint && hint.syntheticException || new Error(message);
      ex.message = message;
    } else {
      ex = hint && hint.syntheticException || new Error(exception);
      ex.message = exception;
    }
    mechanism.synthetic = true;
  }
  const event = {
    exception: {
      values: [exceptionFromError(stackParser, ex)]
    }
  };
  misc.addExceptionTypeValue(event, void 0, void 0);
  misc.addExceptionMechanism(event, mechanism);
  return {
    ...event,
    event_id: hint && hint.event_id
  };
}
function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
  const event = {
    event_id: hint && hint.event_id,
    level,
    message
  };
  if (attachStacktrace && hint && hint.syntheticException) {
    const frames = parseStackFrames(stackParser, hint.syntheticException);
    if (frames.length) {
      event.exception = {
        values: [
          {
            value: message,
            stacktrace: { frames }
          }
        ]
      };
    }
  }
  return event;
}
exports.eventFromMessage = eventFromMessage;
exports.eventFromUnknownInput = eventFromUnknownInput;
exports.exceptionFromError = exceptionFromError;
exports.parseStackFrames = parseStackFrames;
//# sourceMappingURL=eventbuilder.cjs.map
