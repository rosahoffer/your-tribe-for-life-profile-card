"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const chalk = require("chalk");
const open = require("open");
const manager = require("@slicemachine/manager");
const createSliceMachineExpressApp = require("./lib/createSliceMachineExpressApp.cjs");
const setupSentry = require("./lib/setupSentry.cjs");
const migrateSMJSON = require("./legacyMigrations/migrateSMJSON.cjs");
const migrateAssets = require("./legacyMigrations/migrateAssets.cjs");
const constants = require("./constants.cjs");
const DEFAULT_SERVER_PORT = 9999;
const createStartSliceMachineProcess = (...args) => {
  return new StartSliceMachineProcess(...args);
};
class StartSliceMachineProcess {
  constructor(args) {
    /**
     * Determines if Slice Machine should automatically be opened once the server
     * starts.
     *
     * @defaultValue `false`
     */
    __publicField(this, "open");
    /**
     * The port on which to start the Slice Machine server.
     *
     * @defaultValue `9999`
     */
    __publicField(this, "port");
    /**
     * The Slice Machine manager used for the process.
     */
    __publicField(this, "_sliceMachineManager");
    this._sliceMachineManager = manager.createSliceMachineManager();
    this.open = args.open ?? false;
    this.port = args.port ?? DEFAULT_SERVER_PORT;
  }
  /**
   * Runs the process.
   */
  async run() {
    var _a, _b, _c, _d;
    await migrateSMJSON.migrateSMJSON(this._sliceMachineManager);
    const appVersion = await this._sliceMachineManager.versions.getRunningSliceMachineVersion();
    await this._sliceMachineManager.telemetry.initTelemetry({
      appName: constants.SLICE_MACHINE_NPM_PACKAGE_NAME,
      appVersion
    });
    const isTelemetryEnabled = await this._sliceMachineManager.telemetry.checkIsTelemetryEnabled();
    if (isTelemetryEnabled) {
      setupSentry.setupSentry(this._sliceMachineManager);
    }
    await this._sliceMachineManager.plugins.initPlugins();
    await migrateAssets.migrateAssets(this._sliceMachineManager);
    await this._validateProject();
    const app = await createSliceMachineExpressApp.createSliceMachineExpressApp({
      sliceMachineManager: this._sliceMachineManager
    });
    const server = app.listen(this.port);
    const address = server.address();
    const url = `http://localhost:${address.port}`;
    if (this.open) {
      await open(url);
    }
    console.log();
    console.log(await this._buildSliceMachineRunningLine(`Running at ${chalk.magenta(url)}`));
    console.log(await this._buildLoggedInAsLine(chalk.dim("Loading...")));
    console.log();
    const profile = await this._fetchProfile();
    (_b = (_a = process.stdout).moveCursor) == null ? void 0 : _b.call(_a, 0, -2);
    (_d = (_c = process.stdout).clearLine) == null ? void 0 : _d.call(_c, 1);
    console.log(await this._buildLoggedInAsLine(profile ? `${[profile.firstName, profile.lastName].filter(Boolean).join(" ")} ${chalk.dim(`(${profile.email})`)}` : chalk.dim("Not logged in")));
    console.log();
    if (profile) {
      this._sliceMachineManager.telemetry.identify({
        userID: profile.shortId,
        intercomHash: profile.intercomHash
      });
    }
    if (profile) {
      await Promise.allSettled([
        // noop - We'll try again when needed.
        this._sliceMachineManager.user.refreshAuthenticationToken(),
        // noop - We'll try again before uploading a screenshot.
        this._sliceMachineManager.screenshots.initS3ACL()
      ]);
    }
  }
  /**
   * Returns a string with Slice Machine info formatted for the console.
   *
   * @param value - Info to display.
   *
   * @returns String to pass to the console.
   */
  async _buildSliceMachineRunningLine(value) {
    const currentVersion = await this._sliceMachineManager.versions.getRunningSliceMachineVersion();
    return `${chalk.bgBlack(` ${chalk.bold.white("Slice Machine")} ${chalk.magenta(`v${currentVersion}`)} `)} ${chalk.dim("→")} ${value}`;
  }
  /**
   * Returns a string with logged in Prismic user info formatted for the
   * console.
   *
   * @param value - User info to display.
   *
   * @returns String to pass to the console.
   */
  async _buildLoggedInAsLine(value) {
    const currentVersion = await this._sliceMachineManager.versions.getRunningSliceMachineVersion();
    return `${chalk.bgBlack(`    ${" ".repeat(currentVersion.length)}${chalk.bold("Logged in as")} `)} ${chalk.dim("→")} ${value}`;
  }
  /**
   * Validates the project's config and content models.
   *
   * @throws Throws if a Library name is invalid.
   * @throws Throws if a Slice model is invalid.
   * @throws Throws if a Custom Type model is invalid.
   */
  async _validateProject() {
    var _a;
    const config = await this._sliceMachineManager.project.loadSliceMachineConfig();
    const invalidLibraries = ((_a = config.libraries) == null ? void 0 : _a.filter((library) => library.startsWith("@") || library.startsWith("~"))) || [];
    if (invalidLibraries.length > 0) {
      throw new Error(`The following Slice libraries have invalid names: ${invalidLibraries.join(", ")}. Slice library names must not start with "@" nor "~".`);
    }
    const allSlices = await this._sliceMachineManager.slices.readAllSlices();
    if (allSlices.errors.length > 0) {
      throw new Error(`Errors occurred while validating your project's slices.

${allSlices.errors.join("\n\n")}`);
    }
    const allCustomTypes = await this._sliceMachineManager.customTypes.readAllCustomTypes();
    if (allCustomTypes.errors.length > 0) {
      throw new Error(allCustomTypes.errors.join(", "));
    }
  }
  /**
   * Fetches the logged in Prismic user's profile. If the user is not logged in,
   * `undefined` is returned.
   *
   * @returns The logged in Prismic user's profile, or `undefined` if not logged
   *   in.
   */
  async _fetchProfile() {
    const isLoggedIn = await this._sliceMachineManager.user.checkIsLoggedIn();
    if (isLoggedIn) {
      return await this._sliceMachineManager.user.getProfile();
    }
  }
}
exports.StartSliceMachineProcess = StartSliceMachineProcess;
exports.createStartSliceMachineProcess = createStartSliceMachineProcess;
//# sourceMappingURL=StartSliceMachineProcess.cjs.map
