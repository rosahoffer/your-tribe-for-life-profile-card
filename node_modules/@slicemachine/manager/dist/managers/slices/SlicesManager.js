import * as t from "io-ts";
import * as prismicCustomTypesClient from "@prismicio/custom-types-client";
import { SharedSliceContent } from "@prismicio/types-internal/lib/content";
import { SliceComparator } from "@prismicio/types-internal/lib/customtypes/diff";
import { SharedSlice } from "@prismicio/types-internal/lib/customtypes";
import { assertPluginsInitialized } from "../../lib/assertPluginsInitialized.js";
import { bufferCodec } from "../../lib/bufferCodec.js";
import { decodeHookResult } from "../../lib/decodeHookResult.js";
import { createContentDigest } from "../../lib/createContentDigest.js";
import { mockSlice } from "../../lib/mockSlice.js";
import fetch from "../../lib/fetch.js";
import { DEFAULT_SLICE_SCREENSHOT_URL } from "../../constants/DEFAULT_SLICE_SCREENSHOT_URL.js";
import { SLICE_MACHINE_USER_AGENT } from "../../constants/SLICE_MACHINE_USER_AGENT.js";
import { API_ENDPOINTS } from "../../constants/API_ENDPOINTS.js";
import { UnauthenticatedError, UnauthorizedError } from "../../errors.js";
import { BaseManager } from "../BaseManager.js";
class SlicesManager extends BaseManager {
  async readSliceLibrary(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice-library:read", args);
    const { data, errors } = decodeHookResult(t.type({
      id: t.string,
      sliceIDs: t.array(t.string)
    }), hookResult);
    return {
      sliceIDs: ((_a = data[0]) == null ? void 0 : _a.sliceIDs) ?? [],
      errors
    };
  }
  async readAllSliceLibraries() {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const libraryIDs = sliceMachineConfig.libraries || [];
    const res = {
      libraries: [],
      errors: []
    };
    for (const libraryID of libraryIDs) {
      const { sliceIDs, errors } = await this.readSliceLibrary({
        libraryID
      });
      res.errors = [...res.errors, ...errors];
      res.libraries.push({
        libraryID,
        sliceIDs
      });
    }
    return res;
  }
  async readAllSlicesForLibrary(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const res = {
      models: [],
      errors: []
    };
    const { sliceIDs, errors } = await this.readSliceLibrary({
      libraryID: args.libraryID
    });
    res.errors.push(...errors);
    if (sliceIDs) {
      for (const sliceID of sliceIDs) {
        const { model, errors: errors2 } = await this.readSlice({
          libraryID: args.libraryID,
          sliceID
        });
        res.errors.push(...errors2);
        if (model) {
          res.models.push({ model });
        }
      }
    }
    return res;
  }
  async readAllSlices() {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const libraryIDs = sliceMachineConfig.libraries || [];
    const res = {
      models: [],
      errors: []
    };
    for (const libraryID of libraryIDs) {
      const { models, errors } = await this.readAllSlicesForLibrary({
        libraryID
      });
      res.errors.push(...errors);
      for (const model of models) {
        res.models.push({
          libraryID,
          model: model.model
        });
      }
    }
    return res;
  }
  async createSlice(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:create", args);
    const updateSliceMocksArgs = {
      libraryID: args.libraryID,
      sliceID: args.model.id,
      mocks: mockSlice({ model: args.model })
    };
    const { errors: updateSliceHookErrors } = await this.updateSliceMocks(updateSliceMocksArgs);
    return {
      errors: [...hookResult.errors, ...updateSliceHookErrors]
    };
  }
  async readSlice(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:read", args);
    const { data, errors } = decodeHookResult(t.type({
      model: SharedSlice
    }), hookResult);
    return {
      model: (_a = data[0]) == null ? void 0 : _a.model,
      errors: errors.map((error) => {
        error.message = `Failed to decode slice model with id '${args.sliceID}': ${error.message}`;
        return error;
      })
    };
  }
  async updateSlice(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const { mocks: previousMocks } = await this.readSliceMocks({
      libraryID: args.libraryID,
      sliceID: args.model.id
    });
    const { model: previousModel } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.model.id
    });
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:update", args);
    const updatedMocks = mockSlice({
      model: args.model,
      mocks: previousMocks,
      diff: SliceComparator.compare(previousModel, args.model)
    });
    const updateSliceMocksArgs = {
      libraryID: args.libraryID,
      sliceID: args.model.id,
      mocks: updatedMocks
    };
    const { errors: updateSliceMocksHookResult } = await this.updateSliceMocks(updateSliceMocksArgs);
    return {
      errors: [...hookResult.errors, ...updateSliceMocksHookResult]
    };
  }
  async renameSlice(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:rename", args);
    return {
      errors: hookResult.errors
    };
  }
  async deleteSlice(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const { model, errors: readSliceErrors } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.sliceID
    });
    if (model) {
      const { errors: deleteSliceErrors } = await this.sliceMachinePluginRunner.callHook("slice:delete", {
        model,
        libraryID: args.libraryID
      });
      if (deleteSliceErrors.length > 0) {
        return {
          errors: deleteSliceErrors
        };
      }
      const { errors: updateCustomTypeErrors } = await this._removeSliceFromCustomTypes(args.sliceID);
      return {
        errors: updateCustomTypeErrors
      };
    } else {
      return {
        errors: readSliceErrors
      };
    }
  }
  /**
   * @returns Record of variation IDs mapped to uploaded screenshot URLs.
   */
  async pushSlice(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    if (!await this.user.checkIsLoggedIn()) {
      throw new UnauthenticatedError();
    }
    const { model, errors: readSliceErrors } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.sliceID
    });
    if (model) {
      const modelWithScreenshots = await this.updateSliceModelScreenshotsInPlace({
        libraryID: args.libraryID,
        model
      });
      const authenticationToken = await this.user.getAuthenticationToken();
      const sliceMachineConfig = await this.project.getSliceMachineConfig();
      const client = prismicCustomTypesClient.createClient({
        endpoint: API_ENDPOINTS.PrismicModels,
        repositoryName: sliceMachineConfig.repositoryName,
        token: authenticationToken,
        userAgent: args.userAgent || SLICE_MACHINE_USER_AGENT,
        fetch
      });
      try {
        await client.getSharedSliceByID(args.sliceID);
        await client.updateSharedSlice(modelWithScreenshots);
      } catch (error) {
        if (error instanceof prismicCustomTypesClient.NotFoundError) {
          await client.insertSharedSlice(modelWithScreenshots);
        } else if (error instanceof prismicCustomTypesClient.ForbiddenError) {
          throw new UnauthorizedError("You do not have access to push Slices to this Prismic repository.");
        } else {
          throw error;
        }
      }
      const screenshotURLs = {};
      for (const variation of modelWithScreenshots.variations) {
        screenshotURLs[variation.id] = variation.imageUrl;
      }
      return {
        screenshotURLs,
        errors: readSliceErrors
      };
    } else {
      return {
        screenshotURLs: void 0,
        errors: readSliceErrors
      };
    }
  }
  async readSliceScreenshot(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:read", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      assetID: `screenshot-${args.variationID}.png`
    });
    const { data, errors } = decodeHookResult(t.type({
      data: bufferCodec
    }), hookResult);
    return {
      data: (_a = data[0]) == null ? void 0 : _a.data,
      errors
    };
  }
  async updateSliceScreenshot(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:update", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      asset: {
        id: `screenshot-${args.variationID}.png`,
        data: args.data
      }
    });
    return {
      errors: hookResult.errors
    };
  }
  async readSliceMocks(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:read", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      assetID: `mocks.json`
    });
    const { data, errors } = decodeHookResult(t.type({
      data: t.array(SharedSliceContent)
    }), {
      ...hookResult,
      // Convert the asset data from a Buffer to JSON
      // to prepare it for validation.
      data: hookResult.data.map((result) => {
        try {
          return {
            ...result,
            data: JSON.parse(result.data.toString())
          };
        } catch {
          return result;
        }
      })
    });
    if (data) {
      return {
        mocks: (_a = data[0]) == null ? void 0 : _a.data,
        errors
      };
    } else {
      return {
        mocks: [],
        errors
      };
    }
  }
  async updateSliceMocks(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:update", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      asset: {
        id: "mocks.json",
        data: Buffer.from(JSON.stringify(args.mocks, null, "	"))
      }
    });
    return {
      errors: hookResult.errors
    };
  }
  // TODO: Remove
  async readSliceMocksConfig(args) {
    var _a;
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:read", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      assetID: "mocks.config.json"
    });
    const data = (_a = hookResult.data[0]) == null ? void 0 : _a.data;
    if (data) {
      return {
        mocksConfig: JSON.parse(data.toString()),
        errors: hookResult.errors
      };
    } else {
      return {
        mocksConfig: void 0,
        errors: hookResult.errors
      };
    }
  }
  async fetchRemoteSlices() {
    const authenticationToken = await this.user.getAuthenticationToken();
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const client = prismicCustomTypesClient.createClient({
      endpoint: API_ENDPOINTS.PrismicModels,
      repositoryName: sliceMachineConfig.repositoryName,
      token: authenticationToken,
      userAgent: SLICE_MACHINE_USER_AGENT,
      fetch
    });
    return await client.getAllSharedSlices();
  }
  async updateSliceModelScreenshotsInPlace(args) {
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const variations = await Promise.all(args.model.variations.map(async (variation) => {
      var _a;
      const screenshot = await this.readSliceScreenshot({
        libraryID: args.libraryID,
        sliceID: args.model.id,
        variationID: variation.id
      });
      if (!screenshot.data) {
        return {
          ...variation,
          imageUrl: DEFAULT_SLICE_SCREENSHOT_URL
        };
      }
      const hasScreenshotChanged = !((_a = variation.imageUrl) == null ? void 0 : _a.includes(createContentDigest(screenshot.data)));
      if (!hasScreenshotChanged) {
        return variation;
      }
      const keyPrefix = [
        sliceMachineConfig.repositoryName,
        "shared-slices",
        args.model.id,
        variation.id
      ].join("/");
      const uploadedScreenshot = await this.screenshots.uploadScreenshot({
        data: screenshot.data,
        keyPrefix
      });
      return {
        ...variation,
        imageUrl: uploadedScreenshot.url
      };
    }));
    return {
      ...args.model,
      variations
    };
  }
  async _removeSliceFromCustomTypes(sliceID) {
    const { models, errors: customTypeReadErrors } = await this.customTypes.readAllCustomTypes();
    await Promise.all(models.map(async (customType) => {
      const updatedJsonModel = Object.entries(customType.model.json).reduce((tabAccumulator, [tabKey, tab]) => {
        const updatedTabFields = Object.entries(tab).reduce((fieldAccumulator, [fieldKey, field]) => {
          if (field.config === void 0 || field.type !== "Slices" || field.config.choices === void 0) {
            return { ...fieldAccumulator, [fieldKey]: field };
          }
          const filteredChoices = Object.entries(field.config.choices).reduce((choiceAccumulator, [choiceKey, choice]) => {
            if (choiceKey === sliceID) {
              return choiceAccumulator;
            }
            return { ...choiceAccumulator, [choiceKey]: choice };
          }, {});
          return {
            ...fieldAccumulator,
            [fieldKey]: {
              ...field,
              config: { ...field.config, choices: filteredChoices }
            }
          };
        }, {});
        return { ...tabAccumulator, [tabKey]: updatedTabFields };
      }, {});
      await this.customTypes.updateCustomType({
        model: { ...customType.model, json: updatedJsonModel }
      });
    }));
    return { errors: customTypeReadErrors };
  }
}
export {
  SlicesManager
};
//# sourceMappingURL=SlicesManager.js.map
