"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("io-ts");
const prismicCustomTypesClient = require("@prismicio/custom-types-client");
const content = require("@prismicio/types-internal/lib/content");
const diff = require("@prismicio/types-internal/lib/customtypes/diff");
const customtypes = require("@prismicio/types-internal/lib/customtypes");
const assertPluginsInitialized = require("../../lib/assertPluginsInitialized.cjs");
const bufferCodec = require("../../lib/bufferCodec.cjs");
const decodeHookResult = require("../../lib/decodeHookResult.cjs");
const createContentDigest = require("../../lib/createContentDigest.cjs");
const mockSlice = require("../../lib/mockSlice.cjs");
const fetch = require("../../lib/fetch.cjs");
const DEFAULT_SLICE_SCREENSHOT_URL = require("../../constants/DEFAULT_SLICE_SCREENSHOT_URL.cjs");
const SLICE_MACHINE_USER_AGENT = require("../../constants/SLICE_MACHINE_USER_AGENT.cjs");
const API_ENDPOINTS = require("../../constants/API_ENDPOINTS.cjs");
const errors = require("../../errors.cjs");
const BaseManager = require("../BaseManager.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const prismicCustomTypesClient__namespace = /* @__PURE__ */ _interopNamespaceDefault(prismicCustomTypesClient);
class SlicesManager extends BaseManager.BaseManager {
  async readSliceLibrary(args) {
    var _a;
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice-library:read", args);
    const { data, errors: errors2 } = decodeHookResult.decodeHookResult(t__namespace.type({
      id: t__namespace.string,
      sliceIDs: t__namespace.array(t__namespace.string)
    }), hookResult);
    return {
      sliceIDs: ((_a = data[0]) == null ? void 0 : _a.sliceIDs) ?? [],
      errors: errors2
    };
  }
  async readAllSliceLibraries() {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const libraryIDs = sliceMachineConfig.libraries || [];
    const res = {
      libraries: [],
      errors: []
    };
    for (const libraryID of libraryIDs) {
      const { sliceIDs, errors: errors2 } = await this.readSliceLibrary({
        libraryID
      });
      res.errors = [...res.errors, ...errors2];
      res.libraries.push({
        libraryID,
        sliceIDs
      });
    }
    return res;
  }
  async readAllSlicesForLibrary(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const res = {
      models: [],
      errors: []
    };
    const { sliceIDs, errors: errors2 } = await this.readSliceLibrary({
      libraryID: args.libraryID
    });
    res.errors.push(...errors2);
    if (sliceIDs) {
      for (const sliceID of sliceIDs) {
        const { model, errors: errors22 } = await this.readSlice({
          libraryID: args.libraryID,
          sliceID
        });
        res.errors.push(...errors22);
        if (model) {
          res.models.push({ model });
        }
      }
    }
    return res;
  }
  async readAllSlices() {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const libraryIDs = sliceMachineConfig.libraries || [];
    const res = {
      models: [],
      errors: []
    };
    for (const libraryID of libraryIDs) {
      const { models, errors: errors2 } = await this.readAllSlicesForLibrary({
        libraryID
      });
      res.errors.push(...errors2);
      for (const model of models) {
        res.models.push({
          libraryID,
          model: model.model
        });
      }
    }
    return res;
  }
  async createSlice(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:create", args);
    const updateSliceMocksArgs = {
      libraryID: args.libraryID,
      sliceID: args.model.id,
      mocks: mockSlice.mockSlice({ model: args.model })
    };
    const { errors: updateSliceHookErrors } = await this.updateSliceMocks(updateSliceMocksArgs);
    return {
      errors: [...hookResult.errors, ...updateSliceHookErrors]
    };
  }
  async readSlice(args) {
    var _a;
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:read", args);
    const { data, errors: errors2 } = decodeHookResult.decodeHookResult(t__namespace.type({
      model: customtypes.SharedSlice
    }), hookResult);
    return {
      model: (_a = data[0]) == null ? void 0 : _a.model,
      errors: errors2.map((error) => {
        error.message = `Failed to decode slice model with id '${args.sliceID}': ${error.message}`;
        return error;
      })
    };
  }
  async updateSlice(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const { mocks: previousMocks } = await this.readSliceMocks({
      libraryID: args.libraryID,
      sliceID: args.model.id
    });
    const { model: previousModel } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.model.id
    });
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:update", args);
    const updatedMocks = mockSlice.mockSlice({
      model: args.model,
      mocks: previousMocks,
      diff: diff.SliceComparator.compare(previousModel, args.model)
    });
    const updateSliceMocksArgs = {
      libraryID: args.libraryID,
      sliceID: args.model.id,
      mocks: updatedMocks
    };
    const { errors: updateSliceMocksHookResult } = await this.updateSliceMocks(updateSliceMocksArgs);
    return {
      errors: [...hookResult.errors, ...updateSliceMocksHookResult]
    };
  }
  async renameSlice(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:rename", args);
    return {
      errors: hookResult.errors
    };
  }
  async deleteSlice(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const { model, errors: readSliceErrors } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.sliceID
    });
    if (model) {
      const { errors: deleteSliceErrors } = await this.sliceMachinePluginRunner.callHook("slice:delete", {
        model,
        libraryID: args.libraryID
      });
      if (deleteSliceErrors.length > 0) {
        return {
          errors: deleteSliceErrors
        };
      }
      const { errors: updateCustomTypeErrors } = await this._removeSliceFromCustomTypes(args.sliceID);
      return {
        errors: updateCustomTypeErrors
      };
    } else {
      return {
        errors: readSliceErrors
      };
    }
  }
  /**
   * @returns Record of variation IDs mapped to uploaded screenshot URLs.
   */
  async pushSlice(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    if (!await this.user.checkIsLoggedIn()) {
      throw new errors.UnauthenticatedError();
    }
    const { model, errors: readSliceErrors } = await this.readSlice({
      libraryID: args.libraryID,
      sliceID: args.sliceID
    });
    if (model) {
      const modelWithScreenshots = await this.updateSliceModelScreenshotsInPlace({
        libraryID: args.libraryID,
        model
      });
      const authenticationToken = await this.user.getAuthenticationToken();
      const sliceMachineConfig = await this.project.getSliceMachineConfig();
      const client = prismicCustomTypesClient__namespace.createClient({
        endpoint: API_ENDPOINTS.API_ENDPOINTS.PrismicModels,
        repositoryName: sliceMachineConfig.repositoryName,
        token: authenticationToken,
        userAgent: args.userAgent || SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT,
        fetch: fetch.default
      });
      try {
        await client.getSharedSliceByID(args.sliceID);
        await client.updateSharedSlice(modelWithScreenshots);
      } catch (error) {
        if (error instanceof prismicCustomTypesClient__namespace.NotFoundError) {
          await client.insertSharedSlice(modelWithScreenshots);
        } else if (error instanceof prismicCustomTypesClient__namespace.ForbiddenError) {
          throw new errors.UnauthorizedError("You do not have access to push Slices to this Prismic repository.");
        } else {
          throw error;
        }
      }
      const screenshotURLs = {};
      for (const variation of modelWithScreenshots.variations) {
        screenshotURLs[variation.id] = variation.imageUrl;
      }
      return {
        screenshotURLs,
        errors: readSliceErrors
      };
    } else {
      return {
        screenshotURLs: void 0,
        errors: readSliceErrors
      };
    }
  }
  async readSliceScreenshot(args) {
    var _a;
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:read", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      assetID: `screenshot-${args.variationID}.png`
    });
    const { data, errors: errors2 } = decodeHookResult.decodeHookResult(t__namespace.type({
      data: bufferCodec.bufferCodec
    }), hookResult);
    return {
      data: (_a = data[0]) == null ? void 0 : _a.data,
      errors: errors2
    };
  }
  async updateSliceScreenshot(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:update", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      asset: {
        id: `screenshot-${args.variationID}.png`,
        data: args.data
      }
    });
    return {
      errors: hookResult.errors
    };
  }
  async readSliceMocks(args) {
    var _a;
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:read", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      assetID: `mocks.json`
    });
    const { data, errors: errors2 } = decodeHookResult.decodeHookResult(t__namespace.type({
      data: t__namespace.array(content.SharedSliceContent)
    }), {
      ...hookResult,
      // Convert the asset data from a Buffer to JSON
      // to prepare it for validation.
      data: hookResult.data.map((result) => {
        try {
          return {
            ...result,
            data: JSON.parse(result.data.toString())
          };
        } catch {
          return result;
        }
      })
    });
    if (data) {
      return {
        mocks: (_a = data[0]) == null ? void 0 : _a.data,
        errors: errors2
      };
    } else {
      return {
        mocks: [],
        errors: errors2
      };
    }
  }
  async updateSliceMocks(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:update", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      asset: {
        id: "mocks.json",
        data: Buffer.from(JSON.stringify(args.mocks, null, "	"))
      }
    });
    return {
      errors: hookResult.errors
    };
  }
  // TODO: Remove
  async readSliceMocksConfig(args) {
    var _a;
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice:asset:read", {
      libraryID: args.libraryID,
      sliceID: args.sliceID,
      assetID: "mocks.config.json"
    });
    const data = (_a = hookResult.data[0]) == null ? void 0 : _a.data;
    if (data) {
      return {
        mocksConfig: JSON.parse(data.toString()),
        errors: hookResult.errors
      };
    } else {
      return {
        mocksConfig: void 0,
        errors: hookResult.errors
      };
    }
  }
  async fetchRemoteSlices() {
    const authenticationToken = await this.user.getAuthenticationToken();
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const client = prismicCustomTypesClient__namespace.createClient({
      endpoint: API_ENDPOINTS.API_ENDPOINTS.PrismicModels,
      repositoryName: sliceMachineConfig.repositoryName,
      token: authenticationToken,
      userAgent: SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT,
      fetch: fetch.default
    });
    return await client.getAllSharedSlices();
  }
  async updateSliceModelScreenshotsInPlace(args) {
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    const variations = await Promise.all(args.model.variations.map(async (variation) => {
      var _a;
      const screenshot = await this.readSliceScreenshot({
        libraryID: args.libraryID,
        sliceID: args.model.id,
        variationID: variation.id
      });
      if (!screenshot.data) {
        return {
          ...variation,
          imageUrl: DEFAULT_SLICE_SCREENSHOT_URL.DEFAULT_SLICE_SCREENSHOT_URL
        };
      }
      const hasScreenshotChanged = !((_a = variation.imageUrl) == null ? void 0 : _a.includes(createContentDigest.createContentDigest(screenshot.data)));
      if (!hasScreenshotChanged) {
        return variation;
      }
      const keyPrefix = [
        sliceMachineConfig.repositoryName,
        "shared-slices",
        args.model.id,
        variation.id
      ].join("/");
      const uploadedScreenshot = await this.screenshots.uploadScreenshot({
        data: screenshot.data,
        keyPrefix
      });
      return {
        ...variation,
        imageUrl: uploadedScreenshot.url
      };
    }));
    return {
      ...args.model,
      variations
    };
  }
  async _removeSliceFromCustomTypes(sliceID) {
    const { models, errors: customTypeReadErrors } = await this.customTypes.readAllCustomTypes();
    await Promise.all(models.map(async (customType) => {
      const updatedJsonModel = Object.entries(customType.model.json).reduce((tabAccumulator, [tabKey, tab]) => {
        const updatedTabFields = Object.entries(tab).reduce((fieldAccumulator, [fieldKey, field]) => {
          if (field.config === void 0 || field.type !== "Slices" || field.config.choices === void 0) {
            return { ...fieldAccumulator, [fieldKey]: field };
          }
          const filteredChoices = Object.entries(field.config.choices).reduce((choiceAccumulator, [choiceKey, choice]) => {
            if (choiceKey === sliceID) {
              return choiceAccumulator;
            }
            return { ...choiceAccumulator, [choiceKey]: choice };
          }, {});
          return {
            ...fieldAccumulator,
            [fieldKey]: {
              ...field,
              config: { ...field.config, choices: filteredChoices }
            }
          };
        }, {});
        return { ...tabAccumulator, [tabKey]: updatedTabFields };
      }, {});
      await this.customTypes.updateCustomType({
        model: { ...customType.model, json: updatedJsonModel }
      });
    }));
    return { errors: customTypeReadErrors };
  }
}
exports.SlicesManager = SlicesManager;
//# sourceMappingURL=SlicesManager.cjs.map
