{"version":3,"file":"ProjectManager.js","sources":["../../../../src/managers/project/ProjectManager.ts"],"sourcesContent":["import * as fs from \"node:fs/promises\";\nimport { existsSync } from \"node:fs\";\nimport * as path from \"node:path\";\nimport { createRequire } from \"node:module\";\nimport { detect as niDetect } from \"@antfu/ni\";\nimport { ExecaChildProcess } from \"execa\";\n\nimport { assertPluginsInitialized } from \"../../lib/assertPluginsInitialized\";\nimport { decodeSliceMachineConfig } from \"../../lib/decodeSliceMachineConfig\";\nimport { format } from \"../../lib/format\";\nimport { installDependencies } from \"../../lib/installDependencies\";\nimport { locateFileUpward } from \"../../lib/locateFileUpward\";\n\nimport { PackageManager, SliceMachineConfig } from \"../../types\";\n\nimport { SliceMachineError, InternalError } from \"../../errors\";\n\nimport { SLICE_MACHINE_CONFIG_FILENAME } from \"../../constants/SLICE_MACHINE_CONFIG_FILENAME\";\nimport { TS_CONFIG_FILENAME } from \"../../constants/TS_CONFIG_FILENAME\";\nimport { SLICE_MACHINE_NPM_PACKAGE_NAME } from \"../../constants/SLICE_MACHINE_NPM_PACKAGE_NAME\";\n\nimport { BaseManager } from \"../BaseManager\";\n\ntype ProjectManagerGetSliceMachineConfigPathArgs = {\n\tignoreCache?: boolean;\n};\n\ntype ProjectManagerGetRootArgs = {\n\tignoreCache?: boolean;\n};\n\ntype ProjectManagerCheckIsTypeScriptArgs = {\n\trootOverride?: string;\n};\n\ntype ProjectManagerWriteSliceMachineConfigArgs = {\n\tconfig: SliceMachineConfig;\n\tpath?: string;\n};\n\ntype ProjectManagerInitProjectArgs = {\n\tlog?: (message: string) => void;\n};\n\ntype ProjectManagerDetectPackageManager = {\n\troot?: string;\n};\n\ntype ProjectManagerInstallDependenciesArgs = {\n\tdependencies: Record<string, string>;\n\tdev?: boolean;\n\tpackageManager?: PackageManager;\n\tlog?: (message: string) => void;\n};\n\ntype ProjectManagerInstallDependenciesReturnType = {\n\texecaProcess: ExecaChildProcess;\n};\n\nexport class ProjectManager extends BaseManager {\n\tprivate _cachedRoot: string | undefined;\n\tprivate _cachedSliceMachineConfigPath: string | undefined;\n\tprivate _cachedSliceMachineConfig: SliceMachineConfig | undefined;\n\n\tasync getSliceMachineConfigPath(\n\t\targs?: ProjectManagerGetSliceMachineConfigPathArgs,\n\t): Promise<string> {\n\t\tif (this._cachedSliceMachineConfigPath && !args?.ignoreCache) {\n\t\t\treturn this._cachedSliceMachineConfigPath;\n\t\t}\n\n\t\ttry {\n\t\t\tthis._cachedSliceMachineConfigPath = await locateFileUpward(\n\t\t\t\tSLICE_MACHINE_CONFIG_FILENAME,\n\t\t\t\t{ startDir: this.cwd },\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tthrow new Error(\n\t\t\t\t`Could not find a ${SLICE_MACHINE_CONFIG_FILENAME} file. Please create a config file at the root of your project.`,\n\t\t\t);\n\t\t}\n\n\t\treturn this._cachedSliceMachineConfigPath;\n\t}\n\n\tasync getRoot(args?: ProjectManagerGetRootArgs): Promise<string> {\n\t\tif (this._cachedRoot && !args?.ignoreCache) {\n\t\t\treturn this._cachedRoot;\n\t\t}\n\n\t\tconst sliceMachineConfigFilePath = await this.getSliceMachineConfigPath({\n\t\t\tignoreCache: args?.ignoreCache,\n\t\t});\n\n\t\tthis._cachedRoot = path.dirname(sliceMachineConfigFilePath);\n\n\t\treturn this._cachedRoot;\n\t}\n\n\tasync suggestRoot(): Promise<string> {\n\t\tconst suggestedRootPackageJSON = await locateFileUpward(\"package.json\", {\n\t\t\tstartDir: this.cwd,\n\t\t});\n\n\t\treturn path.dirname(suggestedRootPackageJSON);\n\t}\n\n\tasync suggestSliceMachineConfigPath(): Promise<string> {\n\t\tconst suggestedRoot = await this.suggestRoot();\n\n\t\treturn path.resolve(suggestedRoot, SLICE_MACHINE_CONFIG_FILENAME);\n\t}\n\n\tasync checkIsTypeScript(\n\t\targs?: ProjectManagerCheckIsTypeScriptArgs,\n\t): Promise<boolean> {\n\t\tconst root = args?.rootOverride || (await this.getRoot());\n\t\tconst rootTSConfigPath = path.resolve(root, TS_CONFIG_FILENAME);\n\n\t\t// We just care if the file exists, we don't need access to it\n\t\treturn existsSync(rootTSConfigPath);\n\t}\n\n\tasync getSliceMachineConfig(): Promise<SliceMachineConfig> {\n\t\tif (this._cachedSliceMachineConfig) {\n\t\t\treturn this._cachedSliceMachineConfig;\n\t\t} else {\n\t\t\treturn await this.loadSliceMachineConfig();\n\t\t}\n\t}\n\n\tasync writeSliceMachineConfig(\n\t\targs: ProjectManagerWriteSliceMachineConfigArgs,\n\t): Promise<void> {\n\t\tconst configFilePath =\n\t\t\targs.path || (await this.getSliceMachineConfigPath());\n\n\t\tconst config = await format(\n\t\t\tJSON.stringify(args.config, null, 2),\n\t\t\tconfigFilePath,\n\t\t);\n\n\t\tawait fs.writeFile(configFilePath, config, \"utf-8\");\n\t\tdelete this._cachedSliceMachineConfig; // Clear config cache\n\t}\n\n\tasync loadSliceMachineConfig(): Promise<SliceMachineConfig> {\n\t\t// TODO: Reload plugins with a fresh plugin runner. Plugins may\n\t\t// have been added or removed.\n\t\tconst configFilePath = await this.getSliceMachineConfigPath();\n\n\t\tlet rawConfig: unknown | undefined;\n\t\ttry {\n\t\t\tconst contents = await fs.readFile(configFilePath, \"utf8\");\n\t\t\trawConfig = JSON.parse(contents);\n\t\t} catch (error) {\n\t\t\tif (error instanceof SyntaxError) {\n\t\t\t\tthrow new SliceMachineError(\n\t\t\t\t\t`Could not parse config file at ${configFilePath}.\\n\\nError Message: ${error.message}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Noop, more specific error is thrown after\n\t\t}\n\n\t\tif (!rawConfig) {\n\t\t\t// TODO: Write a more friendly and useful message.\n\t\t\tthrow new Error(\"No config found.\");\n\t\t}\n\n\t\tconst { value: sliceMachineConfig, error } =\n\t\t\tdecodeSliceMachineConfig(rawConfig);\n\n\t\tif (error) {\n\t\t\t// TODO: Write a more friendly and useful message.\n\t\t\tthrow new Error(`Invalid config. ${error.errors.join(\", \")}`);\n\t\t}\n\n\t\t// Allow cached config reading using `SliceMachineManager.prototype.getProjectConfig()`.\n\t\tthis._cachedSliceMachineConfig = sliceMachineConfig;\n\n\t\treturn sliceMachineConfig;\n\t}\n\n\tasync locateSliceMachineUIDir(): Promise<string> {\n\t\tconst projectRoot = await this.getRoot();\n\n\t\tconst require = createRequire(path.join(projectRoot, \"index.js\"));\n\t\tconst sliceMachinePackageJSONPath = require.resolve(\n\t\t\t`${SLICE_MACHINE_NPM_PACKAGE_NAME}/package.json`,\n\t\t);\n\n\t\treturn path.dirname(sliceMachinePackageJSONPath);\n\t}\n\n\tasync getRepositoryName(): Promise<string> {\n\t\tconst sliceMachineConfig = await this.getSliceMachineConfig();\n\n\t\treturn sliceMachineConfig.repositoryName;\n\t}\n\n\tasync getAdapterName(): Promise<string> {\n\t\tconst sliceMachineConfig = await this.getSliceMachineConfig();\n\t\tconst adapterName =\n\t\t\ttypeof sliceMachineConfig.adapter === \"string\"\n\t\t\t\t? sliceMachineConfig.adapter\n\t\t\t\t: sliceMachineConfig.adapter.resolve;\n\n\t\treturn adapterName;\n\t}\n\n\tasync locateAdapterDir(): Promise<string> {\n\t\tconst projectRoot = await this.getRoot();\n\t\tconst adapterName = await this.getAdapterName();\n\t\tconst require = createRequire(path.join(projectRoot, \"index.js\"));\n\t\tconst adapterPackageJSONPath = require.resolve(\n\t\t\t`${adapterName}/package.json`,\n\t\t);\n\n\t\treturn path.dirname(adapterPackageJSONPath);\n\t}\n\n\tasync initProject(args?: ProjectManagerInitProjectArgs): Promise<void> {\n\t\tassertPluginsInitialized(this.sliceMachinePluginRunner);\n\n\t\t// eslint-disable-next-line no-console\n\t\tconst log = args?.log || console.log.bind(this);\n\n\t\tconst { errors } = await this.sliceMachinePluginRunner.callHook(\n\t\t\t\"project:init\",\n\t\t\t{\n\t\t\t\tlog,\n\t\t\t\tinstallDependencies: async (args) => {\n\t\t\t\t\tconst { execaProcess } = await this.installDependencies({\n\t\t\t\t\t\tdependencies: args.dependencies,\n\t\t\t\t\t\tdev: args.dev,\n\t\t\t\t\t\tlog,\n\t\t\t\t\t});\n\n\t\t\t\t\tawait execaProcess;\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tif (errors.length > 0) {\n\t\t\t// TODO: Provide better error message.\n\t\t\tthrow new SliceMachineError(\n\t\t\t\t`Failed to initialize project: ${errors.join(\", \")}`,\n\t\t\t);\n\t\t}\n\t}\n\n\tasync detectPackageManager(\n\t\targs?: ProjectManagerDetectPackageManager,\n\t): Promise<PackageManager> {\n\t\tconst projectRoot = args?.root || (await this.getRoot());\n\n\t\tconst packageManager = await niDetect({\n\t\t\tautoInstall: true,\n\t\t\tcwd: projectRoot,\n\t\t});\n\n\t\treturn packageManager || \"npm\";\n\t}\n\n\tasync installDependencies(\n\t\targs: ProjectManagerInstallDependenciesArgs,\n\t): Promise<ProjectManagerInstallDependenciesReturnType> {\n\t\tconst packageManager =\n\t\t\targs.packageManager || (await this.detectPackageManager());\n\n\t\t// eslint-disable-next-line no-console\n\t\tconst log = args.log || console.log.bind(this);\n\n\t\tconst wrappedLogger = (data: Buffer | string | null) => {\n\t\t\tif (data instanceof Buffer) {\n\t\t\t\tlog(data.toString());\n\t\t\t} else if (typeof data === \"string\") {\n\t\t\t\tlog(data);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\tconst { execaProcess } = await installDependencies({\n\t\t\t\tpackageManager,\n\t\t\t\tdependencies: args.dependencies,\n\t\t\t\tdev: args.dev,\n\t\t\t});\n\n\t\t\t// Don't clutter console with logs when process is non TTY (CI, etc.)\n\t\t\tif (process.stdout.isTTY || process.env.NODE_ENV === \"test\") {\n\t\t\t\texecaProcess.stdout?.on(\"data\", wrappedLogger);\n\t\t\t}\n\t\t\texecaProcess.stderr?.on(\"data\", wrappedLogger);\n\n\t\t\treturn {\n\t\t\t\texecaProcess,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\terror instanceof Error &&\n\t\t\t\t\"shortMessage\" in error &&\n\t\t\t\t\"stderr\" in error\n\t\t\t) {\n\t\t\t\tthrow new InternalError(\"Package installation failed\", {\n\t\t\t\t\tcause: error,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n"],"names":["error","require","args","niDetect"],"mappings":"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"}