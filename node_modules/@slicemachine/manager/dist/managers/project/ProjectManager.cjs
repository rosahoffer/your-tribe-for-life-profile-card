"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const fs = require("node:fs/promises");
const node_fs = require("node:fs");
const path = require("node:path");
const node_module = require("node:module");
const ni = require("@antfu/ni");
const assertPluginsInitialized = require("../../lib/assertPluginsInitialized.cjs");
const decodeSliceMachineConfig = require("../../lib/decodeSliceMachineConfig.cjs");
const format = require("../../lib/format.cjs");
const installDependencies = require("../../lib/installDependencies.cjs");
const locateFileUpward = require("../../lib/locateFileUpward.cjs");
const errors = require("../../errors.cjs");
const SLICE_MACHINE_CONFIG_FILENAME = require("../../constants/SLICE_MACHINE_CONFIG_FILENAME.cjs");
const TS_CONFIG_FILENAME = require("../../constants/TS_CONFIG_FILENAME.cjs");
const SLICE_MACHINE_NPM_PACKAGE_NAME = require("../../constants/SLICE_MACHINE_NPM_PACKAGE_NAME.cjs");
const BaseManager = require("../BaseManager.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs);
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
class ProjectManager extends BaseManager.BaseManager {
  constructor() {
    super(...arguments);
    __publicField(this, "_cachedRoot");
    __publicField(this, "_cachedSliceMachineConfigPath");
    __publicField(this, "_cachedSliceMachineConfig");
  }
  async getSliceMachineConfigPath(args) {
    if (this._cachedSliceMachineConfigPath && !(args == null ? void 0 : args.ignoreCache)) {
      return this._cachedSliceMachineConfigPath;
    }
    try {
      this._cachedSliceMachineConfigPath = await locateFileUpward.locateFileUpward(SLICE_MACHINE_CONFIG_FILENAME.SLICE_MACHINE_CONFIG_FILENAME, { startDir: this.cwd });
    } catch (error) {
      throw new Error(`Could not find a ${SLICE_MACHINE_CONFIG_FILENAME.SLICE_MACHINE_CONFIG_FILENAME} file. Please create a config file at the root of your project.`);
    }
    return this._cachedSliceMachineConfigPath;
  }
  async getRoot(args) {
    if (this._cachedRoot && !(args == null ? void 0 : args.ignoreCache)) {
      return this._cachedRoot;
    }
    const sliceMachineConfigFilePath = await this.getSliceMachineConfigPath({
      ignoreCache: args == null ? void 0 : args.ignoreCache
    });
    this._cachedRoot = path__namespace.dirname(sliceMachineConfigFilePath);
    return this._cachedRoot;
  }
  async suggestRoot() {
    const suggestedRootPackageJSON = await locateFileUpward.locateFileUpward("package.json", {
      startDir: this.cwd
    });
    return path__namespace.dirname(suggestedRootPackageJSON);
  }
  async suggestSliceMachineConfigPath() {
    const suggestedRoot = await this.suggestRoot();
    return path__namespace.resolve(suggestedRoot, SLICE_MACHINE_CONFIG_FILENAME.SLICE_MACHINE_CONFIG_FILENAME);
  }
  async checkIsTypeScript(args) {
    const root = (args == null ? void 0 : args.rootOverride) || await this.getRoot();
    const rootTSConfigPath = path__namespace.resolve(root, TS_CONFIG_FILENAME.TS_CONFIG_FILENAME);
    return node_fs.existsSync(rootTSConfigPath);
  }
  async getSliceMachineConfig() {
    if (this._cachedSliceMachineConfig) {
      return this._cachedSliceMachineConfig;
    } else {
      return await this.loadSliceMachineConfig();
    }
  }
  async writeSliceMachineConfig(args) {
    const configFilePath = args.path || await this.getSliceMachineConfigPath();
    const config = await format.format(JSON.stringify(args.config, null, 2), configFilePath);
    await fs__namespace.writeFile(configFilePath, config, "utf-8");
    delete this._cachedSliceMachineConfig;
  }
  async loadSliceMachineConfig() {
    const configFilePath = await this.getSliceMachineConfigPath();
    let rawConfig;
    try {
      const contents = await fs__namespace.readFile(configFilePath, "utf8");
      rawConfig = JSON.parse(contents);
    } catch (error2) {
      if (error2 instanceof SyntaxError) {
        throw new errors.SliceMachineError(`Could not parse config file at ${configFilePath}.

Error Message: ${error2.message}`);
      }
    }
    if (!rawConfig) {
      throw new Error("No config found.");
    }
    const { value: sliceMachineConfig, error } = decodeSliceMachineConfig.decodeSliceMachineConfig(rawConfig);
    if (error) {
      throw new Error(`Invalid config. ${error.errors.join(", ")}`);
    }
    this._cachedSliceMachineConfig = sliceMachineConfig;
    return sliceMachineConfig;
  }
  async locateSliceMachineUIDir() {
    const projectRoot = await this.getRoot();
    const require2 = node_module.createRequire(path__namespace.join(projectRoot, "index.js"));
    const sliceMachinePackageJSONPath = require2.resolve(`${SLICE_MACHINE_NPM_PACKAGE_NAME.SLICE_MACHINE_NPM_PACKAGE_NAME}/package.json`);
    return path__namespace.dirname(sliceMachinePackageJSONPath);
  }
  async getRepositoryName() {
    const sliceMachineConfig = await this.getSliceMachineConfig();
    return sliceMachineConfig.repositoryName;
  }
  async getAdapterName() {
    const sliceMachineConfig = await this.getSliceMachineConfig();
    const adapterName = typeof sliceMachineConfig.adapter === "string" ? sliceMachineConfig.adapter : sliceMachineConfig.adapter.resolve;
    return adapterName;
  }
  async locateAdapterDir() {
    const projectRoot = await this.getRoot();
    const adapterName = await this.getAdapterName();
    const require2 = node_module.createRequire(path__namespace.join(projectRoot, "index.js"));
    const adapterPackageJSONPath = require2.resolve(`${adapterName}/package.json`);
    return path__namespace.dirname(adapterPackageJSONPath);
  }
  async initProject(args) {
    assertPluginsInitialized.assertPluginsInitialized(this.sliceMachinePluginRunner);
    const log = (args == null ? void 0 : args.log) || console.log.bind(this);
    const { errors: errors$1 } = await this.sliceMachinePluginRunner.callHook("project:init", {
      log,
      installDependencies: async (args2) => {
        const { execaProcess } = await this.installDependencies({
          dependencies: args2.dependencies,
          dev: args2.dev,
          log
        });
        await execaProcess;
      }
    });
    if (errors$1.length > 0) {
      throw new errors.SliceMachineError(`Failed to initialize project: ${errors$1.join(", ")}`);
    }
  }
  async detectPackageManager(args) {
    const projectRoot = (args == null ? void 0 : args.root) || await this.getRoot();
    const packageManager = await ni.detect({
      autoInstall: true,
      cwd: projectRoot
    });
    return packageManager || "npm";
  }
  async installDependencies(args) {
    var _a, _b;
    const packageManager = args.packageManager || await this.detectPackageManager();
    const log = args.log || console.log.bind(this);
    const wrappedLogger = (data) => {
      if (data instanceof Buffer) {
        log(data.toString());
      } else if (typeof data === "string") {
        log(data);
      }
    };
    try {
      const { execaProcess } = await installDependencies.installDependencies({
        packageManager,
        dependencies: args.dependencies,
        dev: args.dev
      });
      if (process.stdout.isTTY || process.env.NODE_ENV === "test") {
        (_a = execaProcess.stdout) == null ? void 0 : _a.on("data", wrappedLogger);
      }
      (_b = execaProcess.stderr) == null ? void 0 : _b.on("data", wrappedLogger);
      return {
        execaProcess
      };
    } catch (error) {
      if (error instanceof Error && "shortMessage" in error && "stderr" in error) {
        throw new errors.InternalError("Package installation failed", {
          cause: error
        });
      }
      throw error;
    }
  }
}
exports.ProjectManager = ProjectManager;
//# sourceMappingURL=ProjectManager.cjs.map
