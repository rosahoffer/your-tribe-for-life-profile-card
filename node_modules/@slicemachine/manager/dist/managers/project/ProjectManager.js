var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as fs from "node:fs/promises";
import { existsSync } from "node:fs";
import * as path from "node:path";
import { createRequire } from "node:module";
import { detect } from "@antfu/ni";
import { assertPluginsInitialized } from "../../lib/assertPluginsInitialized.js";
import { decodeSliceMachineConfig } from "../../lib/decodeSliceMachineConfig.js";
import { format } from "../../lib/format.js";
import { installDependencies } from "../../lib/installDependencies.js";
import { locateFileUpward } from "../../lib/locateFileUpward.js";
import { SliceMachineError, InternalError } from "../../errors.js";
import { SLICE_MACHINE_CONFIG_FILENAME } from "../../constants/SLICE_MACHINE_CONFIG_FILENAME.js";
import { TS_CONFIG_FILENAME } from "../../constants/TS_CONFIG_FILENAME.js";
import { SLICE_MACHINE_NPM_PACKAGE_NAME } from "../../constants/SLICE_MACHINE_NPM_PACKAGE_NAME.js";
import { BaseManager } from "../BaseManager.js";
class ProjectManager extends BaseManager {
  constructor() {
    super(...arguments);
    __publicField(this, "_cachedRoot");
    __publicField(this, "_cachedSliceMachineConfigPath");
    __publicField(this, "_cachedSliceMachineConfig");
  }
  async getSliceMachineConfigPath(args) {
    if (this._cachedSliceMachineConfigPath && !(args == null ? void 0 : args.ignoreCache)) {
      return this._cachedSliceMachineConfigPath;
    }
    try {
      this._cachedSliceMachineConfigPath = await locateFileUpward(SLICE_MACHINE_CONFIG_FILENAME, { startDir: this.cwd });
    } catch (error) {
      throw new Error(`Could not find a ${SLICE_MACHINE_CONFIG_FILENAME} file. Please create a config file at the root of your project.`);
    }
    return this._cachedSliceMachineConfigPath;
  }
  async getRoot(args) {
    if (this._cachedRoot && !(args == null ? void 0 : args.ignoreCache)) {
      return this._cachedRoot;
    }
    const sliceMachineConfigFilePath = await this.getSliceMachineConfigPath({
      ignoreCache: args == null ? void 0 : args.ignoreCache
    });
    this._cachedRoot = path.dirname(sliceMachineConfigFilePath);
    return this._cachedRoot;
  }
  async suggestRoot() {
    const suggestedRootPackageJSON = await locateFileUpward("package.json", {
      startDir: this.cwd
    });
    return path.dirname(suggestedRootPackageJSON);
  }
  async suggestSliceMachineConfigPath() {
    const suggestedRoot = await this.suggestRoot();
    return path.resolve(suggestedRoot, SLICE_MACHINE_CONFIG_FILENAME);
  }
  async checkIsTypeScript(args) {
    const root = (args == null ? void 0 : args.rootOverride) || await this.getRoot();
    const rootTSConfigPath = path.resolve(root, TS_CONFIG_FILENAME);
    return existsSync(rootTSConfigPath);
  }
  async getSliceMachineConfig() {
    if (this._cachedSliceMachineConfig) {
      return this._cachedSliceMachineConfig;
    } else {
      return await this.loadSliceMachineConfig();
    }
  }
  async writeSliceMachineConfig(args) {
    const configFilePath = args.path || await this.getSliceMachineConfigPath();
    const config = await format(JSON.stringify(args.config, null, 2), configFilePath);
    await fs.writeFile(configFilePath, config, "utf-8");
    delete this._cachedSliceMachineConfig;
  }
  async loadSliceMachineConfig() {
    const configFilePath = await this.getSliceMachineConfigPath();
    let rawConfig;
    try {
      const contents = await fs.readFile(configFilePath, "utf8");
      rawConfig = JSON.parse(contents);
    } catch (error2) {
      if (error2 instanceof SyntaxError) {
        throw new SliceMachineError(`Could not parse config file at ${configFilePath}.

Error Message: ${error2.message}`);
      }
    }
    if (!rawConfig) {
      throw new Error("No config found.");
    }
    const { value: sliceMachineConfig, error } = decodeSliceMachineConfig(rawConfig);
    if (error) {
      throw new Error(`Invalid config. ${error.errors.join(", ")}`);
    }
    this._cachedSliceMachineConfig = sliceMachineConfig;
    return sliceMachineConfig;
  }
  async locateSliceMachineUIDir() {
    const projectRoot = await this.getRoot();
    const require2 = createRequire(path.join(projectRoot, "index.js"));
    const sliceMachinePackageJSONPath = require2.resolve(`${SLICE_MACHINE_NPM_PACKAGE_NAME}/package.json`);
    return path.dirname(sliceMachinePackageJSONPath);
  }
  async getRepositoryName() {
    const sliceMachineConfig = await this.getSliceMachineConfig();
    return sliceMachineConfig.repositoryName;
  }
  async getAdapterName() {
    const sliceMachineConfig = await this.getSliceMachineConfig();
    const adapterName = typeof sliceMachineConfig.adapter === "string" ? sliceMachineConfig.adapter : sliceMachineConfig.adapter.resolve;
    return adapterName;
  }
  async locateAdapterDir() {
    const projectRoot = await this.getRoot();
    const adapterName = await this.getAdapterName();
    const require2 = createRequire(path.join(projectRoot, "index.js"));
    const adapterPackageJSONPath = require2.resolve(`${adapterName}/package.json`);
    return path.dirname(adapterPackageJSONPath);
  }
  async initProject(args) {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const log = (args == null ? void 0 : args.log) || console.log.bind(this);
    const { errors } = await this.sliceMachinePluginRunner.callHook("project:init", {
      log,
      installDependencies: async (args2) => {
        const { execaProcess } = await this.installDependencies({
          dependencies: args2.dependencies,
          dev: args2.dev,
          log
        });
        await execaProcess;
      }
    });
    if (errors.length > 0) {
      throw new SliceMachineError(`Failed to initialize project: ${errors.join(", ")}`);
    }
  }
  async detectPackageManager(args) {
    const projectRoot = (args == null ? void 0 : args.root) || await this.getRoot();
    const packageManager = await detect({
      autoInstall: true,
      cwd: projectRoot
    });
    return packageManager || "npm";
  }
  async installDependencies(args) {
    var _a, _b;
    const packageManager = args.packageManager || await this.detectPackageManager();
    const log = args.log || console.log.bind(this);
    const wrappedLogger = (data) => {
      if (data instanceof Buffer) {
        log(data.toString());
      } else if (typeof data === "string") {
        log(data);
      }
    };
    try {
      const { execaProcess } = await installDependencies({
        packageManager,
        dependencies: args.dependencies,
        dev: args.dev
      });
      if (process.stdout.isTTY || process.env.NODE_ENV === "test") {
        (_a = execaProcess.stdout) == null ? void 0 : _a.on("data", wrappedLogger);
      }
      (_b = execaProcess.stderr) == null ? void 0 : _b.on("data", wrappedLogger);
      return {
        execaProcess
      };
    } catch (error) {
      if (error instanceof Error && "shortMessage" in error && "stderr" in error) {
        throw new InternalError("Package installation failed", {
          cause: error
        });
      }
      throw error;
    }
  }
}
export {
  ProjectManager
};
//# sourceMappingURL=ProjectManager.js.map
