import * as t from "io-ts";
import fetch from "../../lib/fetch.js";
import { assertPluginsInitialized } from "../../lib/assertPluginsInitialized.js";
import { castArray } from "../../lib/castArray.js";
import { decode } from "../../lib/decode.js";
import { decodeHookResult } from "../../lib/decodeHookResult.js";
import { functionCodec } from "../../lib/functionCodec.js";
import { markdownToHTML } from "../../lib/markdownToHTML.js";
import { UnexpectedDataError } from "../../errors.js";
import { BaseManager } from "../BaseManager.js";
const sliceSimulatorSetupStepCodec = t.intersection([
  t.type({
    title: t.string,
    body: t.string
  }),
  t.partial({
    description: t.string,
    validate: functionCodec
  })
]);
const SliceSimulatorSetupStepValidationMessageCodec = t.type({
  title: t.string,
  message: t.string
});
class SimulatorManager extends BaseManager {
  async getLocalSliceSimulatorURL() {
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    return sliceMachineConfig.localSliceSimulatorURL;
  }
  /**
   * @throws {@link UnexpectedDataError} Thrown if the project is not configured
   *   with a Slice Simulator URL.
   */
  async checkIsLocalSliceSimulatorURLAccessible() {
    const localSliceSimulatorURL = await this.getLocalSliceSimulatorURL();
    if (!localSliceSimulatorURL) {
      throw new UnexpectedDataError("The project has not been configured with a Slice Simulator URL. Add a `localSliceSimulatorURL` property to your project's configuration to fix this error.");
    }
    const res = await fetch(localSliceSimulatorURL);
    return res.ok;
  }
  async readSliceSimulatorSetupSteps() {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hookResult = await this.sliceMachinePluginRunner.callHook("slice-simulator:setup:read", void 0);
    const { data, errors } = decodeHookResult(t.array(sliceSimulatorSetupStepCodec), hookResult);
    const steps = await Promise.all(data[0].map(async (step) => {
      const bodyHTML = await markdownToHTML(step.body);
      const res = {
        title: step.title,
        description: step.description,
        body: bodyHTML,
        isComplete: void 0,
        validationMessages: []
      };
      if (step.validate) {
        const validationResult = await step.validate();
        const { value: validationMessages, error } = decode(t.array(SliceSimulatorSetupStepValidationMessageCodec), validationResult == null ? [] : castArray(validationResult));
        if (error) {
          return res;
        }
        const isComplete = validationMessages.length < 1;
        const processedValidationMessages = await Promise.all(validationMessages.map(async (validationMessage) => {
          const messageHTML = await markdownToHTML(validationMessage.message);
          return {
            ...validationMessage,
            message: messageHTML
          };
        }));
        res.isComplete = isComplete;
        res.validationMessages = processedValidationMessages;
      }
      return res;
    }));
    return {
      steps,
      errors
    };
  }
  supportsSliceSimulator() {
    assertPluginsInitialized(this.sliceMachinePluginRunner);
    const hooks = this.sliceMachinePluginRunner.hooksForType("slice-simulator:setup:read");
    return hooks.length > 0;
  }
}
export {
  SimulatorManager
};
//# sourceMappingURL=SimulatorManager.js.map
