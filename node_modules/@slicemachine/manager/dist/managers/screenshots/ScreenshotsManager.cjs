"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const t = require("io-ts");
require("readable-web-to-node-stream");
const core = require('./../../_node_modules/file-type/core.cjs');
const fetch = require("../../lib/fetch.cjs");
const checkIsURLAccessible = require("../../lib/checkIsURLAccessible.cjs");
const createContentDigest = require("../../lib/createContentDigest.cjs");
const decode = require("../../lib/decode.cjs");
const SLICE_MACHINE_USER_AGENT = require("../../constants/SLICE_MACHINE_USER_AGENT.cjs");
const API_ENDPOINTS = require("../../constants/API_ENDPOINTS.cjs");
const BaseManager = require("../BaseManager.cjs");
const esm_min = require('./../../_node_modules/formdata-polyfill/esm.min.cjs');
require("node:http");
require("node:https");
require("node:zlib");
require("node:stream");
require("node:buffer");
require("node:fs");
require("node:path");
require('./../../_node_modules/node-domexception/index.cjs');
const index = require('./../../_node_modules/fetch-blob/index.cjs');
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const t__namespace = /* @__PURE__ */ _interopNamespaceDefault(t);
const SLICE_SIMULATOR_WAIT_FOR_SELECTOR = "#__iframe-ready";
const SLICE_SIMULATOR_WAIT_FOR_SELECTOR_TIMEOUT = 1e4;
const SLICE_SIMULATOR_SCREENSHOT_SELECTOR = "#__iframe-renderer";
const DEFAULT_SCREENSHOT_VIEWPORT = {
  width: 1200,
  height: 800
};
function assertS3ACLInitialized(s3ACL) {
  if (s3ACL == void 0) {
    throw new Error("An S3 ACL has not been initialized. Run `SliceMachineManager.screenshots.prototype.initS3ACL()` before re-calling this method.");
  }
}
function assertBrowserContextInitialized(browserContext) {
  if (browserContext == void 0) {
    throw new Error("A browser context has not been initialized. Run `SliceMachineManager.screenshots.prototype.initBrowserContext()` before re-calling this method.");
  }
}
const encodeSliceSimulatorURLPart = (urlPart) => {
  return urlPart.replace(/\//g, "--");
};
class ScreenshotsManager extends BaseManager.BaseManager {
  constructor() {
    super(...arguments);
    __publicField(this, "_browserContext");
    __publicField(this, "_s3ACL");
  }
  async initBrowserContext() {
  }
  async initS3ACL() {
    const awsACLURL = new URL("create", API_ENDPOINTS.API_ENDPOINTS.AwsAclProvider);
    const awsACLRes = await this._fetch({ url: awsACLURL });
    const awsACLText = await awsACLRes.text();
    let awsACLJSON;
    try {
      awsACLJSON = JSON.parse(awsACLText);
    } catch (error2) {
      throw new Error(`Invalid AWS ACL response from ${awsACLURL}: ${awsACLText}`);
    }
    const { value: awsACL, error } = decode.decode(t__namespace.intersection([
      t__namespace.type({
        values: t__namespace.type({
          url: t__namespace.string,
          fields: t__namespace.record(t__namespace.string, t__namespace.string)
        }),
        imgixEndpoint: t__namespace.string
      }),
      t__namespace.partial({
        message: t__namespace.string,
        Message: t__namespace.string,
        error: t__namespace.string
      })
    ]), awsACLJSON);
    if (error) {
      throw new Error(`Invalid AWS ACL response from ${awsACLURL}`);
    }
    const errorMessage = awsACL.error || awsACL.message || awsACL.Message;
    if (errorMessage) {
      throw new Error(`Failed to create an AWS ACL: ${errorMessage}`);
    }
    this._s3ACL = {
      uploadEndpoint: awsACL.values.url,
      requiredFormDataFields: awsACL.values.fields,
      imgixEndpoint: awsACL.imgixEndpoint
    };
  }
  // TODO: Abstract to a generic `captureScreenshot()` method that is
  // used within a Slice-specific method in SliceManager.
  async captureSliceSimulatorScreenshot(args) {
    assertBrowserContextInitialized(this._browserContext);
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    if (!sliceMachineConfig.localSliceSimulatorURL) {
      throw new Error("A local Slice Simulator URL must be configured in your Slice Machine configuration file.");
    }
    const { model } = await this.slices.readSlice({
      libraryID: args.libraryID,
      sliceID: args.sliceID
    });
    if (!model) {
      throw new Error(`Did not find a Slice in library "${args.libraryID}" with ID "${args.sliceID}".`);
    }
    const viewport = args.viewport || DEFAULT_SCREENSHOT_VIEWPORT;
    const url = new URL(`./${encodeSliceSimulatorURLPart(args.libraryID)}/${model.name}/${args.variationID}/screenshot`, args.sliceMachineUIOrigin);
    url.searchParams.set("screenWidth", viewport.width.toString());
    url.searchParams.set("screenHeight", viewport.height.toString());
    const isURLAccessible = await checkIsURLAccessible.checkIsURLAccessible(url.toString());
    if (!isURLAccessible) {
      throw new Error(`Slice Simulator screenshot URL is not accessible: ${url}`);
    }
    const page = await this._browserContext.newPage();
    page.setViewport(viewport);
    await page.goto(url.toString(), { waitUntil: ["load", "networkidle0"] });
    await page.waitForSelector(SLICE_SIMULATOR_WAIT_FOR_SELECTOR, {
      timeout: SLICE_SIMULATOR_WAIT_FOR_SELECTOR_TIMEOUT
    });
    const element = await page.$(SLICE_SIMULATOR_SCREENSHOT_SELECTOR);
    if (!element) {
      const baseURL = new URL(url.pathname, url.origin);
      throw new Error(`Slice Simulator did not find ${SLICE_SIMULATOR_WAIT_FOR_SELECTOR} on the page. Verify the URL is correct: ${baseURL}`);
    }
    const data = await element.screenshot({
      encoding: "binary",
      clip: {
        width: viewport.width,
        height: viewport.height,
        x: 0,
        y: 0
      }
    });
    return {
      data
    };
  }
  async uploadScreenshot(args) {
    assertS3ACLInitialized(this._s3ACL);
    const formData = new esm_min.FormData();
    for (const requiredFormDataFieldKey in this._s3ACL.requiredFormDataFields) {
      formData.append(requiredFormDataFieldKey, this._s3ACL.requiredFormDataFields[requiredFormDataFieldKey]);
    }
    const contentDigest = createContentDigest.createContentDigest(args.data);
    const fileType = await core.fileTypeFromBuffer(args.data);
    const fileName = fileType ? `${contentDigest}.${fileType.ext}` : contentDigest;
    const key = args.keyPrefix ? `${args.keyPrefix}/${fileName}` : fileName;
    formData.set("key", key);
    if (fileType) {
      formData.set("Content-Type", fileType.mime);
    }
    formData.set("file", new index.default([args.data], { type: fileType == null ? void 0 : fileType.mime }));
    const res = await fetch.default(this._s3ACL.uploadEndpoint, {
      method: "POST",
      body: formData
    });
    if (res.ok) {
      const url = new URL(key, this._s3ACL.imgixEndpoint);
      url.searchParams.set("auto", "compress,format");
      return {
        url: url.toString()
      };
    } else {
      throw new Error(`Unable to upload screenshot with status code: ${res.status}`);
    }
  }
  async deleteScreenshotFolder(args) {
    const res = await this._fetch({
      // We're sending `args.sliceID` as `sliceName` because it's inconsistently
      // named in the ACL Provider API.
      body: { sliceName: args.sliceID },
      method: "POST",
      url: new URL("delete-folder", API_ENDPOINTS.API_ENDPOINTS.AwsAclProvider)
    });
    if (!res.ok) {
      throw new Error(`Unable to delete screenshot folder with status code: ${res.status}`);
    }
  }
  async _fetch(args) {
    const authenticationToken = await this.user.getAuthenticationToken();
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    return await fetch.default(args.url, {
      body: args.body ? JSON.stringify(args.body) : void 0,
      headers: {
        Authorization: `Bearer ${authenticationToken}`,
        Repository: sliceMachineConfig.repositoryName,
        "User-Agent": SLICE_MACHINE_USER_AGENT.SLICE_MACHINE_USER_AGENT,
        ...args.body ? { "Content-Type": "application/json" } : {}
      },
      method: args.method
    });
  }
}
exports.ScreenshotsManager = ScreenshotsManager;
//# sourceMappingURL=ScreenshotsManager.cjs.map
