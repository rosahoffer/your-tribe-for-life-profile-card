var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import * as t from "io-ts";
import "readable-web-to-node-stream";
import { fileTypeFromBuffer } from './../../_node_modules/file-type/core.js';
import fetch from "../../lib/fetch.js";
import { checkIsURLAccessible } from "../../lib/checkIsURLAccessible.js";
import { createContentDigest } from "../../lib/createContentDigest.js";
import { decode } from "../../lib/decode.js";
import { SLICE_MACHINE_USER_AGENT } from "../../constants/SLICE_MACHINE_USER_AGENT.js";
import { API_ENDPOINTS } from "../../constants/API_ENDPOINTS.js";
import { BaseManager } from "../BaseManager.js";
import { FormData } from './../../_node_modules/formdata-polyfill/esm.min.js';
import "node:http";
import "node:https";
import "node:zlib";
import "node:stream";
import "node:buffer";
import "node:fs";
import "node:path";
import './../../_node_modules/node-domexception/index.js';
import Blob from './../../_node_modules/fetch-blob/index.js';
const SLICE_SIMULATOR_WAIT_FOR_SELECTOR = "#__iframe-ready";
const SLICE_SIMULATOR_WAIT_FOR_SELECTOR_TIMEOUT = 1e4;
const SLICE_SIMULATOR_SCREENSHOT_SELECTOR = "#__iframe-renderer";
const DEFAULT_SCREENSHOT_VIEWPORT = {
  width: 1200,
  height: 800
};
function assertS3ACLInitialized(s3ACL) {
  if (s3ACL == void 0) {
    throw new Error("An S3 ACL has not been initialized. Run `SliceMachineManager.screenshots.prototype.initS3ACL()` before re-calling this method.");
  }
}
function assertBrowserContextInitialized(browserContext) {
  if (browserContext == void 0) {
    throw new Error("A browser context has not been initialized. Run `SliceMachineManager.screenshots.prototype.initBrowserContext()` before re-calling this method.");
  }
}
const encodeSliceSimulatorURLPart = (urlPart) => {
  return urlPart.replace(/\//g, "--");
};
class ScreenshotsManager extends BaseManager {
  constructor() {
    super(...arguments);
    __publicField(this, "_browserContext");
    __publicField(this, "_s3ACL");
  }
  async initBrowserContext() {
  }
  async initS3ACL() {
    const awsACLURL = new URL("create", API_ENDPOINTS.AwsAclProvider);
    const awsACLRes = await this._fetch({ url: awsACLURL });
    const awsACLText = await awsACLRes.text();
    let awsACLJSON;
    try {
      awsACLJSON = JSON.parse(awsACLText);
    } catch (error2) {
      throw new Error(`Invalid AWS ACL response from ${awsACLURL}: ${awsACLText}`);
    }
    const { value: awsACL, error } = decode(t.intersection([
      t.type({
        values: t.type({
          url: t.string,
          fields: t.record(t.string, t.string)
        }),
        imgixEndpoint: t.string
      }),
      t.partial({
        message: t.string,
        Message: t.string,
        error: t.string
      })
    ]), awsACLJSON);
    if (error) {
      throw new Error(`Invalid AWS ACL response from ${awsACLURL}`);
    }
    const errorMessage = awsACL.error || awsACL.message || awsACL.Message;
    if (errorMessage) {
      throw new Error(`Failed to create an AWS ACL: ${errorMessage}`);
    }
    this._s3ACL = {
      uploadEndpoint: awsACL.values.url,
      requiredFormDataFields: awsACL.values.fields,
      imgixEndpoint: awsACL.imgixEndpoint
    };
  }
  // TODO: Abstract to a generic `captureScreenshot()` method that is
  // used within a Slice-specific method in SliceManager.
  async captureSliceSimulatorScreenshot(args) {
    assertBrowserContextInitialized(this._browserContext);
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    if (!sliceMachineConfig.localSliceSimulatorURL) {
      throw new Error("A local Slice Simulator URL must be configured in your Slice Machine configuration file.");
    }
    const { model } = await this.slices.readSlice({
      libraryID: args.libraryID,
      sliceID: args.sliceID
    });
    if (!model) {
      throw new Error(`Did not find a Slice in library "${args.libraryID}" with ID "${args.sliceID}".`);
    }
    const viewport = args.viewport || DEFAULT_SCREENSHOT_VIEWPORT;
    const url = new URL(`./${encodeSliceSimulatorURLPart(args.libraryID)}/${model.name}/${args.variationID}/screenshot`, args.sliceMachineUIOrigin);
    url.searchParams.set("screenWidth", viewport.width.toString());
    url.searchParams.set("screenHeight", viewport.height.toString());
    const isURLAccessible = await checkIsURLAccessible(url.toString());
    if (!isURLAccessible) {
      throw new Error(`Slice Simulator screenshot URL is not accessible: ${url}`);
    }
    const page = await this._browserContext.newPage();
    page.setViewport(viewport);
    await page.goto(url.toString(), { waitUntil: ["load", "networkidle0"] });
    await page.waitForSelector(SLICE_SIMULATOR_WAIT_FOR_SELECTOR, {
      timeout: SLICE_SIMULATOR_WAIT_FOR_SELECTOR_TIMEOUT
    });
    const element = await page.$(SLICE_SIMULATOR_SCREENSHOT_SELECTOR);
    if (!element) {
      const baseURL = new URL(url.pathname, url.origin);
      throw new Error(`Slice Simulator did not find ${SLICE_SIMULATOR_WAIT_FOR_SELECTOR} on the page. Verify the URL is correct: ${baseURL}`);
    }
    const data = await element.screenshot({
      encoding: "binary",
      clip: {
        width: viewport.width,
        height: viewport.height,
        x: 0,
        y: 0
      }
    });
    return {
      data
    };
  }
  async uploadScreenshot(args) {
    assertS3ACLInitialized(this._s3ACL);
    const formData = new FormData();
    for (const requiredFormDataFieldKey in this._s3ACL.requiredFormDataFields) {
      formData.append(requiredFormDataFieldKey, this._s3ACL.requiredFormDataFields[requiredFormDataFieldKey]);
    }
    const contentDigest = createContentDigest(args.data);
    const fileType = await fileTypeFromBuffer(args.data);
    const fileName = fileType ? `${contentDigest}.${fileType.ext}` : contentDigest;
    const key = args.keyPrefix ? `${args.keyPrefix}/${fileName}` : fileName;
    formData.set("key", key);
    if (fileType) {
      formData.set("Content-Type", fileType.mime);
    }
    formData.set("file", new Blob([args.data], { type: fileType == null ? void 0 : fileType.mime }));
    const res = await fetch(this._s3ACL.uploadEndpoint, {
      method: "POST",
      body: formData
    });
    if (res.ok) {
      const url = new URL(key, this._s3ACL.imgixEndpoint);
      url.searchParams.set("auto", "compress,format");
      return {
        url: url.toString()
      };
    } else {
      throw new Error(`Unable to upload screenshot with status code: ${res.status}`);
    }
  }
  async deleteScreenshotFolder(args) {
    const res = await this._fetch({
      // We're sending `args.sliceID` as `sliceName` because it's inconsistently
      // named in the ACL Provider API.
      body: { sliceName: args.sliceID },
      method: "POST",
      url: new URL("delete-folder", API_ENDPOINTS.AwsAclProvider)
    });
    if (!res.ok) {
      throw new Error(`Unable to delete screenshot folder with status code: ${res.status}`);
    }
  }
  async _fetch(args) {
    const authenticationToken = await this.user.getAuthenticationToken();
    const sliceMachineConfig = await this.project.getSliceMachineConfig();
    return await fetch(args.url, {
      body: args.body ? JSON.stringify(args.body) : void 0,
      headers: {
        Authorization: `Bearer ${authenticationToken}`,
        Repository: sliceMachineConfig.repositoryName,
        "User-Agent": SLICE_MACHINE_USER_AGENT,
        ...args.body ? { "Content-Type": "application/json" } : {}
      },
      method: args.method
    });
  }
}
export {
  ScreenshotsManager
};
//# sourceMappingURL=ScreenshotsManager.js.map
