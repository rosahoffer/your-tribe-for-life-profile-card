var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { randomUUID } from "node:crypto";
import SegmentClient from "analytics-node";
import { readPrismicrc } from "../../lib/prismicrc.js";
import { API_TOKENS } from "../../constants/API_TOKENS.js";
import { BaseManager } from "../BaseManager.js";
import { HumanSegmentEventType } from "./types.js";
function assertTelemetryInitialized(segmentClient) {
  if (segmentClient == void 0) {
    throw new Error("Telemetry has not been initialized. Run `SliceMachineManager.telemetry.prototype.initTelemetry()` before re-calling this method.");
  }
}
class TelemetryManager extends BaseManager {
  constructor() {
    super(...arguments);
    __publicField(this, "_segmentClient");
    __publicField(this, "_anonymousID");
    __publicField(this, "_userID");
    __publicField(this, "_context");
  }
  async initTelemetry(args) {
    if (this._segmentClient) {
      return;
    }
    this._segmentClient = new SegmentClient(API_TOKENS.SegmentKey, {
      // Since it's a local app, we do not benefit from event batching the way a server would normally do, all tracking event will be awaited.
      flushAt: 1,
      // TODO: Verify that this actually does not send data to Segment when false.
      enable: await this.checkIsTelemetryEnabled(),
      errorHandler: () => {
      }
    });
    this._anonymousID = randomUUID();
    this._context = { app: { name: args.appName, version: args.appVersion } };
  }
  // TODO: Should `userId` be automatically populated by the logged in
  // user? We already have their info via UserRepository.
  async track(args) {
    var _a;
    const { event, repository, ...properties } = args;
    let repositoryName = repository;
    if (repositoryName === void 0) {
      try {
        repositoryName = await this.project.getRepositoryName();
      } catch (error) {
      }
    }
    const payload = {
      event: HumanSegmentEventType[event],
      properties: {
        nodeVersion: process.versions.node,
        ...properties
      },
      context: { ...this._context }
    };
    if (this._userID) {
      payload.userId = this._userID;
    } else {
      payload.anonymousId = this._anonymousID;
    }
    if (repositoryName) {
      payload.context || (payload.context = {});
      (_a = payload.context).groupId || (_a.groupId = {});
      payload.context.groupId.Repository = repositoryName;
    }
    return new Promise((resolve) => {
      assertTelemetryInitialized(this._segmentClient);
      this._segmentClient.track(payload, (maybeError) => {
        if (maybeError && false) {
          console.warn(`An error occurred during Segment tracking`, maybeError);
        }
        resolve();
      });
    });
  }
  // TODO: Should `userID` and `intercomHash` be automatically populated
  // by the logged in user? We already have their info via
  // UserRepository.
  identify(args) {
    const payload = {
      userId: args.userID,
      anonymousId: this._anonymousID,
      integrations: {
        Intercom: {
          user_hash: args.intercomHash
        }
      },
      context: { ...this._context }
    };
    this._userID = args.userID;
    return new Promise((resolve) => {
      assertTelemetryInitialized(this._segmentClient);
      this._segmentClient.identify(payload, (maybeError) => {
        if (maybeError && false) {
          console.warn(`An error occurred during Segment identify`, maybeError);
        }
        resolve();
      });
    });
  }
  async group(args) {
    var _a;
    let repositoryName;
    try {
      repositoryName = await this.project.getRepositoryName();
    } catch (error) {
    }
    const payload = {
      traits: args,
      context: { ...this._context }
    };
    if (this._userID) {
      payload.userId = this._userID;
    } else {
      payload.anonymousId = this._anonymousID;
    }
    if (repositoryName) {
      payload.groupId = repositoryName;
      payload.context || (payload.context = {});
      (_a = payload.context).groupId || (_a.groupId = {});
      payload.context.groupId.Repository = repositoryName;
    }
    return new Promise((resolve) => {
      assertTelemetryInitialized(this._segmentClient);
      this._segmentClient.group(payload, (maybeError) => {
        if (maybeError && false) {
          console.warn(`An error occurred during Segment group`, maybeError);
        }
        resolve();
      });
    });
  }
  async checkIsTelemetryEnabled() {
    let root;
    try {
      root = await this.project.getRoot();
    } catch {
      root = await this.project.suggestRoot();
    }
    return readPrismicrc(root).telemetry !== false;
  }
}
export {
  TelemetryManager
};
//# sourceMappingURL=TelemetryManager.js.map
