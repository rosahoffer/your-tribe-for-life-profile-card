"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const pluginKit = require("@slicemachine/plugin-kit");
const fs = require("@slicemachine/plugin-kit/fs");
const rejectIfNecessary = require("./lib/rejectIfNecessary.cjs");
const upsertSliceLibraryIndexFile = require("./lib/upsertSliceLibraryIndexFile.cjs");
const _package = require("./packages/adapter-sveltekit/package.json.cjs");
const projectInit = require("./hooks/project-init.cjs");
const sliceCreate = require("./hooks/slice-create.cjs");
const sliceSimulatorSetupRead = require("./hooks/sliceSimulator-setup-read.cjs");
const snippetRead = require("./hooks/snippet-read.cjs");
const plugin = pluginKit.defineSliceMachinePlugin({
  meta: {
    name: _package.name
  },
  defaultOptions: {
    format: true,
    generatedTypesFilePath: "./src/prismicio-types.d.ts"
  },
  setup({ hook }) {
    hook("project:init", projectInit.projectInit);
    hook("slice:create", sliceCreate.sliceCreate);
    hook("slice:update", async (data, context) => {
      await fs.writeSliceModel({
        libraryID: data.libraryID,
        model: data.model,
        ...context
      });
      await fs.upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("slice:rename", async (data, context) => {
      await fs.renameSlice({
        libraryID: data.libraryID,
        model: data.model,
        format: context.options.format,
        ...context
      });
      rejectIfNecessary.rejectIfNecessary(await Promise.allSettled([
        upsertSliceLibraryIndexFile.upsertSliceLibraryIndexFile({
          libraryID: data.libraryID,
          ...context
        }),
        fs.upsertGlobalTypeScriptTypes({
          filename: context.options.generatedTypesFilePath,
          format: context.options.format,
          ...context
        })
      ]));
    });
    hook("slice:delete", async (data, context) => {
      await fs.deleteSliceDirectory({
        libraryID: data.libraryID,
        model: data.model,
        ...context
      });
      rejectIfNecessary.rejectIfNecessary(await Promise.allSettled([
        upsertSliceLibraryIndexFile.upsertSliceLibraryIndexFile({
          libraryID: data.libraryID,
          ...context
        }),
        fs.upsertGlobalTypeScriptTypes({
          filename: context.options.generatedTypesFilePath,
          format: context.options.format,
          ...context
        })
      ]));
    });
    hook("slice:read", async (data, context) => {
      return await fs.readSliceModel({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        ...context
      });
    });
    hook("slice:asset:update", async (data, context) => {
      await fs.writeSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.asset.id,
        contents: data.asset.data,
        ...context
      });
    });
    hook("slice:asset:delete", async (data, context) => {
      await fs.deleteSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.assetID,
        ...context
      });
    });
    hook("slice:asset:read", async (data, context) => {
      const file = await fs.readSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.assetID,
        ...context
      });
      return {
        data: file
      };
    });
    hook("slice-library:read", async (data, context) => {
      return await fs.readSliceLibrary({
        libraryID: data.libraryID,
        ...context
      });
    });
    hook("custom-type:create", async (data, context) => {
      await fs.writeCustomTypeModel({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await fs.upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:update", async (data, context) => {
      await fs.writeCustomTypeModel({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await fs.upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:rename", async (data, context) => {
      await fs.writeCustomTypeModel({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await fs.upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:delete", async (data, context) => {
      await fs.deleteCustomTypeDirectory({
        customTypeID: data.model.id,
        ...context
      });
      await fs.upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:read", async (data, context) => {
      return await fs.readCustomTypeModel({
        customTypeID: data.id,
        ...context
      });
    });
    hook("custom-type:asset:update", async (data, context) => {
      await fs.writeCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.asset.id,
        contents: data.asset.data,
        ...context
      });
    });
    hook("custom-type:asset:delete", async (data, context) => {
      await fs.deleteCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.assetID,
        ...context
      });
    });
    hook("custom-type:asset:read", async (data, context) => {
      const file = await fs.readCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.assetID,
        ...context
      });
      return {
        data: file
      };
    });
    hook("custom-type-library:read", async (_data, context) => {
      return await fs.readCustomTypeLibrary({
        helpers: context.helpers
      });
    });
    hook("snippet:read", snippetRead.snippetRead);
    hook("documentation:read", async (_data, _context) => {
      return [];
    });
    hook("slice-simulator:setup:read", sliceSimulatorSetupRead.sliceSimulatorSetupRead);
  }
});
exports.plugin = plugin;
//# sourceMappingURL=plugin.cjs.map
