"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const path = require("node:path");
const fs = require("@slicemachine/plugin-kit/fs");
const commonTags = require("common-tags");
const checkIsTypeScriptProject = require("../lib/checkIsTypeScriptProject.cjs");
const getJSFileExtension = require("../lib/getJSFileExtension.cjs");
const rejectIfNecessary = require("../lib/rejectIfNecessary.cjs");
const upsertSliceLibraryIndexFile = require("../lib/upsertSliceLibraryIndexFile.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
const installDependencies = async ({ installDependencies: installDependencies2 }) => {
  await installDependencies2({
    dependencies: {
      "@prismicio/client": "latest",
      "@prismicio/svelte": "latest"
    }
  });
};
const createPrismicIOFile = async ({ helpers, options }) => {
  const isTypeScriptProject = await checkIsTypeScriptProject.checkIsTypeScriptProject({
    helpers,
    options
  });
  const extension = await getJSFileExtension.getJSFileExtension({ helpers, options });
  const filename = path__namespace.join(`src/lib/prismicio.${extension}`);
  if (await fs.checkHasProjectFile({ filename, helpers })) {
    return;
  }
  let createClientContents;
  if (isTypeScriptProject) {
    createClientContents = commonTags.source`
			/**
			 * Creates a Prismic client for the project's repository. The client is used to
			 * query content from the Prismic API.
			 *
			 * @param config - Configuration for the Prismic client.
			 */
			export const createClient = (config: prismic.ClientConfig = {}) => {
				const client = prismic.createClient(repositoryName, {
					routes,
					...config,
				});

				return client;
			};
		`;
  } else {
    createClientContents = commonTags.source`
			/**
			 * Creates a Prismic client for the project's repository. The client is used to
			 * query content from the Prismic API.
			 *
			 * @param {prismic.ClientConfig} config - Configuration for the Prismic client.
			 */
			export const createClient = (config = {}) => {
				const client = prismic.createClient(repositoryName, {
					routes,
					...config,
				});

				return client;
			};
		`;
  }
  let contents;
  if (isTypeScriptProject) {
    contents = commonTags.source`
			import * as prismic from "@prismicio/client";
			import config from "../../slicemachine.config.json";

			/**
			 * The project's Prismic repository name.
			 */
			export const repositoryName = config.repositoryName;

			/**
			 * A list of Route Resolver objects that define how a document's \`url\` field is resolved.
			 *
			 * {@link https://prismic.io/docs/route-resolver#route-resolver}
			 */
			// TODO: Update the routes array to match your project's route structure.
			const routes: prismic.ClientConfig["routes"] = [
				{
					type: "homepage",
					path: "/",
				},
				{
					type: "page",
					path: "/:uid",
				},
			];

			${createClientContents}
		`;
  } else {
    contents = commonTags.source`
			import * as prismic from "@prismicio/client";
			import config from "../../slicemachine.config.json";

			/**
			 * The project's Prismic repository name.
			 */
			export const repositoryName = config.repositoryName;

			/**
			 * A list of Route Resolver objects that define how a document's \`url\` field is resolved.
			 *
			 * {@link https://prismic.io/docs/route-resolver#route-resolver}
			 *
			 * @type {prismic.ClientConfig["routes"]}
			 */
			// TODO: Update the routes array to match your project's route structure.
			const routes = [
				{
					type: "homepage",
					path: "/",
				},
				{
					type: "page",
					path: "/:uid",
				},
			];

			${createClientContents}
		`;
  }
  await fs.writeProjectFile({
    filename,
    contents,
    format: options.format,
    helpers
  });
};
const createSliceSimulatorPage = async ({ helpers, options }) => {
  const filename = path__namespace.join("src", "routes", "slice-simulator", "+page.svelte");
  if (await fs.checkHasProjectFile({ filename, helpers })) {
    return;
  }
  const contents = commonTags.source(_a || (_a = __template(["\n		<script>\n			import { SliceSimulator } from '@slicemachine/adapter-sveltekit/simulator';\n			import { SliceZone } from '@prismicio/svelte';\n			import { components } from '$lib/slices';\n		<\/script>\n\n		<SliceSimulator let:slices>\n			<SliceZone {slices} {components} />\n		</SliceSimulator>\n	"])));
  await fs.writeProjectFile({
    filename,
    contents,
    format: options.format,
    formatOptions: {
      prettier: {
        plugins: ["prettier-plugin-svelte"],
        parser: "svelte"
      }
    },
    helpers
  });
};
const modifySliceMachineConfig = async ({ helpers, options, actions }) => {
  var _a2;
  const project = await helpers.getProject();
  (_a2 = project.config).localSliceSimulatorURL || (_a2.localSliceSimulatorURL = "http://localhost:5173/slice-simulator");
  if (await fs.checkHasProjectFile({
    filename: "./src/lib",
    helpers
  }) && project.config.libraries && JSON.stringify(project.config.libraries) === JSON.stringify(["./slices"])) {
    const sliceLibrary = await actions.readSliceLibrary({
      libraryID: project.config.libraries[0]
    });
    if (sliceLibrary.sliceIDs.length < 1) {
      project.config.libraries = ["./src/lib/slices"];
    }
  }
  await helpers.updateSliceMachineConfig(project.config, {
    format: options.format
  });
};
const upsertSliceLibraryIndexFiles = async (context) => {
  var _a2;
  const project = await context.helpers.getProject();
  if (!project.config.libraries) {
    return;
  }
  await Promise.all((_a2 = project.config.libraries) == null ? void 0 : _a2.map(async (libraryID) => {
    await upsertSliceLibraryIndexFile.upsertSliceLibraryIndexFile({ libraryID, ...context });
  }));
};
const projectInit = async ({ installDependencies: _installDependencies }, context) => {
  rejectIfNecessary.rejectIfNecessary(await Promise.allSettled([
    installDependencies({ installDependencies: _installDependencies }),
    modifySliceMachineConfig(context),
    createPrismicIOFile(context),
    createSliceSimulatorPage(context)
  ]));
  await upsertSliceLibraryIndexFiles(context);
};
exports.projectInit = projectInit;
//# sourceMappingURL=project-init.cjs.map
