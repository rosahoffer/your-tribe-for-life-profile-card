import { defineSliceMachinePlugin } from "@slicemachine/plugin-kit";
import { writeSliceModel, upsertGlobalTypeScriptTypes, renameSlice, deleteSliceDirectory, readSliceModel, writeSliceFile, deleteSliceFile, readSliceFile, readSliceLibrary, writeCustomTypeModel, deleteCustomTypeDirectory, readCustomTypeModel, writeCustomTypeFile, deleteCustomTypeFile, readCustomTypeFile, readCustomTypeLibrary } from "@slicemachine/plugin-kit/fs";
import { rejectIfNecessary } from "./lib/rejectIfNecessary.js";
import { upsertSliceLibraryIndexFile } from "./lib/upsertSliceLibraryIndexFile.js";
import { name } from "./packages/adapter-sveltekit/package.json.js";
import { projectInit } from "./hooks/project-init.js";
import { sliceCreate } from "./hooks/slice-create.js";
import { sliceSimulatorSetupRead } from "./hooks/sliceSimulator-setup-read.js";
import { snippetRead } from "./hooks/snippet-read.js";
const plugin = defineSliceMachinePlugin({
  meta: {
    name
  },
  defaultOptions: {
    format: true,
    generatedTypesFilePath: "./src/prismicio-types.d.ts"
  },
  setup({ hook }) {
    hook("project:init", projectInit);
    hook("slice:create", sliceCreate);
    hook("slice:update", async (data, context) => {
      await writeSliceModel({
        libraryID: data.libraryID,
        model: data.model,
        ...context
      });
      await upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("slice:rename", async (data, context) => {
      await renameSlice({
        libraryID: data.libraryID,
        model: data.model,
        format: context.options.format,
        ...context
      });
      rejectIfNecessary(await Promise.allSettled([
        upsertSliceLibraryIndexFile({
          libraryID: data.libraryID,
          ...context
        }),
        upsertGlobalTypeScriptTypes({
          filename: context.options.generatedTypesFilePath,
          format: context.options.format,
          ...context
        })
      ]));
    });
    hook("slice:delete", async (data, context) => {
      await deleteSliceDirectory({
        libraryID: data.libraryID,
        model: data.model,
        ...context
      });
      rejectIfNecessary(await Promise.allSettled([
        upsertSliceLibraryIndexFile({
          libraryID: data.libraryID,
          ...context
        }),
        upsertGlobalTypeScriptTypes({
          filename: context.options.generatedTypesFilePath,
          format: context.options.format,
          ...context
        })
      ]));
    });
    hook("slice:read", async (data, context) => {
      return await readSliceModel({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        ...context
      });
    });
    hook("slice:asset:update", async (data, context) => {
      await writeSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.asset.id,
        contents: data.asset.data,
        ...context
      });
    });
    hook("slice:asset:delete", async (data, context) => {
      await deleteSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.assetID,
        ...context
      });
    });
    hook("slice:asset:read", async (data, context) => {
      const file = await readSliceFile({
        libraryID: data.libraryID,
        sliceID: data.sliceID,
        filename: data.assetID,
        ...context
      });
      return {
        data: file
      };
    });
    hook("slice-library:read", async (data, context) => {
      return await readSliceLibrary({
        libraryID: data.libraryID,
        ...context
      });
    });
    hook("custom-type:create", async (data, context) => {
      await writeCustomTypeModel({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:update", async (data, context) => {
      await writeCustomTypeModel({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:rename", async (data, context) => {
      await writeCustomTypeModel({
        model: data.model,
        format: context.options.format,
        ...context
      });
      await upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:delete", async (data, context) => {
      await deleteCustomTypeDirectory({
        customTypeID: data.model.id,
        ...context
      });
      await upsertGlobalTypeScriptTypes({
        filename: context.options.generatedTypesFilePath,
        format: context.options.format,
        ...context
      });
    });
    hook("custom-type:read", async (data, context) => {
      return await readCustomTypeModel({
        customTypeID: data.id,
        ...context
      });
    });
    hook("custom-type:asset:update", async (data, context) => {
      await writeCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.asset.id,
        contents: data.asset.data,
        ...context
      });
    });
    hook("custom-type:asset:delete", async (data, context) => {
      await deleteCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.assetID,
        ...context
      });
    });
    hook("custom-type:asset:read", async (data, context) => {
      const file = await readCustomTypeFile({
        customTypeID: data.customTypeID,
        filename: data.assetID,
        ...context
      });
      return {
        data: file
      };
    });
    hook("custom-type-library:read", async (_data, context) => {
      return await readCustomTypeLibrary({
        helpers: context.helpers
      });
    });
    hook("snippet:read", snippetRead);
    hook("documentation:read", async (_data, _context) => {
      return [];
    });
    hook("slice-simulator:setup:read", sliceSimulatorSetupRead);
  }
});
export {
  plugin
};
//# sourceMappingURL=plugin.js.map
