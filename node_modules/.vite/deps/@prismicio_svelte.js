import {
  DEV
} from "./chunk-IP2U24VQ.js";
import "./chunk-XML7UXAA.js";
import {
  asImagePixelDensitySrcSet,
  asImageWidthSrcSet,
  asLinkAttrs,
  asText,
  isFilled_exports
} from "./chunk-AP3FVX3M.js";
import {
  asTree
} from "./chunk-KVLCJU4F.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_text,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  src_url_equal,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-ICOQBKZO.js";
import "./chunk-LYBY5SRM.js";
import "./chunk-E3EO7R6B.js";

// node_modules/@prismicio/svelte/dist/PrismicEmbed.svelte
var file = "node_modules/@prismicio/svelte/dist/PrismicEmbed.svelte";
function create_if_block(ctx) {
  let div;
  let html_tag;
  let raw_value = (
    /*field*/
    ctx[0].html + ""
  );
  let div_data_oembed_value;
  let div_data_oembed_type_value;
  let div_data_oembed_provider_value;
  const block = {
    c: function create() {
      div = element("div");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-oembed": true,
        "data-oembed-type": true,
        "data-oembed-provider": true
      });
      var div_nodes = children(div);
      html_tag = claim_html_tag(div_nodes, false);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(div, "data-oembed", div_data_oembed_value = /*field*/
      ctx[0].embed_url);
      attr_dev(div, "data-oembed-type", div_data_oembed_type_value = /*field*/
      ctx[0].type);
      attr_dev(div, "data-oembed-provider", div_data_oembed_provider_value = /*field*/
      ctx[0].provider_name);
      add_location(div, file, 15, 1, 289);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      html_tag.m(raw_value, div);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*field*/
      1 && raw_value !== (raw_value = /*field*/
      ctx2[0].html + ""))
        html_tag.p(raw_value);
      if (dirty & /*field*/
      1 && div_data_oembed_value !== (div_data_oembed_value = /*field*/
      ctx2[0].embed_url)) {
        attr_dev(div, "data-oembed", div_data_oembed_value);
      }
      if (dirty & /*field*/
      1 && div_data_oembed_type_value !== (div_data_oembed_type_value = /*field*/
      ctx2[0].type)) {
        attr_dev(div, "data-oembed-type", div_data_oembed_type_value);
      }
      if (dirty & /*field*/
      1 && div_data_oembed_provider_value !== (div_data_oembed_provider_value = /*field*/
      ctx2[0].provider_name)) {
        attr_dev(div, "data-oembed-provider", div_data_oembed_provider_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(15:0) {#if isFilled.embed(field)}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let show_if = isFilled_exports.embed(
    /*field*/
    ctx[0]
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*field*/
      1)
        show_if = isFilled_exports.embed(
          /*field*/
          ctx2[0]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PrismicEmbed", slots, []);
  let { field } = $$props;
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<PrismicEmbed> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PrismicEmbed> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  $$self.$capture_state = () => ({ isFilled: isFilled_exports, field });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [field];
}
var PrismicEmbed = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { field: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PrismicEmbed",
      options,
      id: create_fragment.name
    });
  }
  get field() {
    throw new Error("<PrismicEmbed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<PrismicEmbed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PrismicEmbed_default = PrismicEmbed;

// node_modules/@prismicio/svelte/dist/PrismicImage.svelte
var file2 = "node_modules/@prismicio/svelte/dist/PrismicImage.svelte";
function create_if_block2(ctx) {
  let img;
  let img_src_value;
  let img_srcset_value;
  let img_alt_value;
  let img_levels = [
    { src: img_src_value = /*src*/
    ctx[3] },
    {
      srcset: img_srcset_value = /*srcset*/
      ctx[4]
    },
    {
      alt: img_alt_value = /*alt*/
      ctx[1] ?? /*field*/
      (ctx[0].alt || /*fallbackAlt*/
      ctx[2])
    },
    { width: (
      /*resolvedWidth*/
      ctx[5]
    ) },
    { height: (
      /*resolvedHeight*/
      ctx[6]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", {
        src: true,
        srcset: true,
        alt: true,
        width: true,
        height: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file2, 74, 1, 2104);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*src*/
        8 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx2[3]) && { src: img_src_value },
        dirty & /*srcset*/
        16 && img_srcset_value !== (img_srcset_value = /*srcset*/
        ctx2[4]) && { srcset: img_srcset_value },
        dirty & /*alt, field, fallbackAlt*/
        7 && img_alt_value !== (img_alt_value = /*alt*/
        ctx2[1] ?? /*field*/
        (ctx2[0].alt || /*fallbackAlt*/
        ctx2[2])) && { alt: img_alt_value },
        dirty & /*resolvedWidth*/
        32 && { width: (
          /*resolvedWidth*/
          ctx2[5]
        ) },
        dirty & /*resolvedHeight*/
        64 && { height: (
          /*resolvedHeight*/
          ctx2[6]
        ) },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx2[7]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(74:0) {#if isFilled.imageThumbnail(field)}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let show_if = isFilled_exports.imageThumbnail(
    /*field*/
    ctx[0]
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*field*/
      1)
        show_if = isFilled_exports.imageThumbnail(
          /*field*/
          ctx2[0]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "field",
    "imgixParams",
    "alt",
    "fallbackAlt",
    "width",
    "height",
    "widths",
    "pixelDensities"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PrismicImage", slots, []);
  let { field } = $$props;
  let { imgixParams = {} } = $$props;
  let { alt = void 0 } = $$props;
  let { fallbackAlt = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { widths = void 0 } = $$props;
  let { pixelDensities = void 0 } = $$props;
  let src = void 0;
  let srcset = void 0;
  let resolvedWidth = void 0;
  let resolvedHeight = void 0;
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<PrismicImage> was created without expected prop 'field'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("field" in $$new_props)
      $$invalidate(0, field = $$new_props.field);
    if ("imgixParams" in $$new_props)
      $$invalidate(8, imgixParams = $$new_props.imgixParams);
    if ("alt" in $$new_props)
      $$invalidate(1, alt = $$new_props.alt);
    if ("fallbackAlt" in $$new_props)
      $$invalidate(2, fallbackAlt = $$new_props.fallbackAlt);
    if ("width" in $$new_props)
      $$invalidate(9, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(10, height = $$new_props.height);
    if ("widths" in $$new_props)
      $$invalidate(11, widths = $$new_props.widths);
    if ("pixelDensities" in $$new_props)
      $$invalidate(12, pixelDensities = $$new_props.pixelDensities);
  };
  $$self.$capture_state = () => ({
    asImageWidthSrcSet,
    asImagePixelDensitySrcSet,
    isFilled: isFilled_exports,
    field,
    imgixParams,
    alt,
    fallbackAlt,
    width,
    height,
    widths,
    pixelDensities,
    src,
    srcset,
    resolvedWidth,
    resolvedHeight
  });
  $$self.$inject_state = ($$new_props) => {
    if ("field" in $$props)
      $$invalidate(0, field = $$new_props.field);
    if ("imgixParams" in $$props)
      $$invalidate(8, imgixParams = $$new_props.imgixParams);
    if ("alt" in $$props)
      $$invalidate(1, alt = $$new_props.alt);
    if ("fallbackAlt" in $$props)
      $$invalidate(2, fallbackAlt = $$new_props.fallbackAlt);
    if ("width" in $$props)
      $$invalidate(9, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(10, height = $$new_props.height);
    if ("widths" in $$props)
      $$invalidate(11, widths = $$new_props.widths);
    if ("pixelDensities" in $$props)
      $$invalidate(12, pixelDensities = $$new_props.pixelDensities);
    if ("src" in $$props)
      $$invalidate(3, src = $$new_props.src);
    if ("srcset" in $$props)
      $$invalidate(4, srcset = $$new_props.srcset);
    if ("resolvedWidth" in $$props)
      $$invalidate(5, resolvedWidth = $$new_props.resolvedWidth);
    if ("resolvedHeight" in $$props)
      $$invalidate(6, resolvedHeight = $$new_props.resolvedHeight);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*field, width, height, widths, pixelDensities, imgixParams*/
    7937) {
      $: {
        if (isFilled_exports.imageThumbnail(field)) {
          const castInt = (input) => {
            if (typeof input === "number" || typeof input === "undefined" || input === null) {
              return input;
            } else {
              const parsed = Number.parseInt(input);
              if (Number.isNaN(parsed)) {
                return void 0;
              } else {
                return parsed;
              }
            }
          };
          const ar = field.dimensions.width / field.dimensions.height;
          const castedWidth = castInt(width);
          const castedHeight = castInt(height);
          $$invalidate(5, resolvedWidth = castedWidth ?? field.dimensions.width);
          $$invalidate(6, resolvedHeight = castedHeight ?? field.dimensions.height);
          if (castedWidth != null && castedHeight == null) {
            $$invalidate(6, resolvedHeight = castedWidth / ar);
          } else if (castedWidth == null && castedHeight != null) {
            $$invalidate(5, resolvedWidth = castedHeight * ar);
          }
          if (widths || !pixelDensities) {
            const res = asImageWidthSrcSet(field, {
              ...imgixParams,
              widths: widths === "defaults" ? void 0 : widths
            });
            $$invalidate(3, src = res.src);
            $$invalidate(4, srcset = res.srcset);
          } else if (pixelDensities) {
            const res = asImagePixelDensitySrcSet(field, {
              ...imgixParams,
              pixelDensities: pixelDensities === "defaults" ? void 0 : pixelDensities
            });
            $$invalidate(3, src = res.src);
            $$invalidate(4, srcset = res.srcset);
          }
        }
      }
    }
  };
  return [
    field,
    alt,
    fallbackAlt,
    src,
    srcset,
    resolvedWidth,
    resolvedHeight,
    $$restProps,
    imgixParams,
    width,
    height,
    widths,
    pixelDensities
  ];
}
var PrismicImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      field: 0,
      imgixParams: 8,
      alt: 1,
      fallbackAlt: 2,
      width: 9,
      height: 10,
      widths: 11,
      pixelDensities: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PrismicImage",
      options,
      id: create_fragment2.name
    });
  }
  get field() {
    throw new Error("<PrismicImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<PrismicImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imgixParams() {
    throw new Error("<PrismicImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imgixParams(value) {
    throw new Error("<PrismicImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<PrismicImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<PrismicImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fallbackAlt() {
    throw new Error("<PrismicImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fallbackAlt(value) {
    throw new Error("<PrismicImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<PrismicImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<PrismicImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<PrismicImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<PrismicImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get widths() {
    throw new Error("<PrismicImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set widths(value) {
    throw new Error("<PrismicImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pixelDensities() {
    throw new Error("<PrismicImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pixelDensities(value) {
    throw new Error("<PrismicImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PrismicImage_default = PrismicImage;

// node_modules/@prismicio/svelte/dist/PrismicLink.svelte
var file3 = "node_modules/@prismicio/svelte/dist/PrismicLink.svelte";
function create_fragment3(ctx) {
  let a;
  let a_href_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let a_levels = [
    /*linkAttrs*/
    ctx[0],
    { rel: (
      /*resolvedRel*/
      ctx[1]
    ) },
    {
      href: a_href_value = /*linkAttrs*/
      ctx[0].href
    },
    /*$$restProps*/
    ctx[2]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { rel: true, href: true });
      var a_nodes = children(a);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      add_location(a, file3, 26, 0, 599);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & /*linkAttrs*/
        1 && /*linkAttrs*/
        ctx2[0],
        (!current || dirty & /*resolvedRel*/
        2) && { rel: (
          /*resolvedRel*/
          ctx2[1]
        ) },
        (!current || dirty & /*linkAttrs*/
        1 && a_href_value !== (a_href_value = /*linkAttrs*/
        ctx2[0].href)) && { href: a_href_value },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let linkAttrs;
  let resolvedRel;
  const omit_props_names = ["field", "document", "rel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PrismicLink", slots, ["default"]);
  let { field = void 0 } = $$props;
  let { document = void 0 } = $$props;
  let { rel = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("field" in $$new_props)
      $$invalidate(3, field = $$new_props.field);
    if ("document" in $$new_props)
      $$invalidate(4, document = $$new_props.document);
    if ("rel" in $$new_props)
      $$invalidate(5, rel = $$new_props.rel);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    asLinkAttrs,
    field,
    document,
    rel,
    linkAttrs,
    resolvedRel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("field" in $$props)
      $$invalidate(3, field = $$new_props.field);
    if ("document" in $$props)
      $$invalidate(4, document = $$new_props.document);
    if ("rel" in $$props)
      $$invalidate(5, rel = $$new_props.rel);
    if ("linkAttrs" in $$props)
      $$invalidate(0, linkAttrs = $$new_props.linkAttrs);
    if ("resolvedRel" in $$props)
      $$invalidate(1, resolvedRel = $$new_props.resolvedRel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*field, document, rel*/
    56) {
      $:
        $$invalidate(0, linkAttrs = asLinkAttrs(field ?? document, {
          rel: typeof rel === "function" ? rel : void 0
        }));
    }
    if ($$self.$$.dirty & /*rel, linkAttrs*/
    33) {
      $:
        $$invalidate(1, resolvedRel = typeof rel === "string" ? rel : linkAttrs.rel);
    }
  };
  return [linkAttrs, resolvedRel, $$restProps, field, document, rel, $$scope, slots];
}
var PrismicLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { field: 3, document: 4, rel: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PrismicLink",
      options,
      id: create_fragment3.name
    });
  }
  get field() {
    throw new Error("<PrismicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<PrismicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get document() {
    throw new Error("<PrismicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set document(value) {
    throw new Error("<PrismicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rel() {
    throw new Error("<PrismicLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rel(value) {
    throw new Error("<PrismicLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PrismicLink_default = PrismicLink;

// node_modules/@prismicio/svelte/dist/PrismicRichText/DefaultComponent.svelte
var file4 = "node_modules/@prismicio/svelte/dist/PrismicRichText/DefaultComponent.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  child_ctx[5] = i;
  return child_ctx;
}
function create_else_block(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*node*/
    ctx[0].text.split("\n")
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*node*/
      1) {
        each_value = ensure_array_like_dev(
          /*node*/
          ctx2[0].text.split("\n")
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(45:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let span;
  let span_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*node*/
      ctx[0].data.label);
      add_location(span, file4, 43, 1, 1268);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*node*/
      1 && span_class_value !== (span_class_value = /*node*/
      ctx2[0].data.label)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(43:32) ",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let prismiclink;
  let current;
  prismiclink = new PrismicLink_default({
    props: {
      field: (
        /*node*/
        ctx[0].data
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(prismiclink.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(prismiclink.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(prismiclink, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const prismiclink_changes = {};
      if (dirty & /*node*/
      1)
        prismiclink_changes.field = /*node*/
        ctx2[0].data;
      if (dirty & /*$$scope*/
      4) {
        prismiclink_changes.$$scope = { dirty, ctx: ctx2 };
      }
      prismiclink.$set(prismiclink_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prismiclink.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prismiclink.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(prismiclink, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(41:36) ",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let prismicembed;
  let current;
  prismicembed = new PrismicEmbed_default({
    props: { field: (
      /*node*/
      ctx[0].oembed
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(prismicembed.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(prismicembed.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(prismicembed, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const prismicembed_changes = {};
      if (dirty & /*node*/
      1)
        prismicembed_changes.field = /*node*/
        ctx2[0].oembed;
      prismicembed.$set(prismicembed_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prismicembed.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prismicembed.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(prismicembed, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(39:32) ",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let p;
  let prismicimage;
  let current;
  prismicimage = new PrismicImage_default({
    props: { field: (
      /*node*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      p = element("p");
      create_component(prismicimage.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      claim_component(prismicimage.$$.fragment, p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "block-img");
      add_location(p, file4, 35, 1, 1011);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      mount_component(prismicimage, p, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const prismicimage_changes = {};
      if (dirty & /*node*/
      1)
        prismicimage_changes.field = /*node*/
        ctx2[0];
      prismicimage.$set(prismicimage_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prismicimage.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prismicimage.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      destroy_component(prismicimage);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(35:32) ",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let ol;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ol = claim_element(nodes, "OL", {});
      var ol_nodes = children(ol);
      if (default_slot)
        default_slot.l(ol_nodes);
      ol_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(ol, file4, 33, 1, 959);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ol, anchor);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ol);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(33:44) ",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let ul;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(ul, file4, 31, 1, 895);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(31:42) ",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      if (default_slot)
        default_slot.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(li, file4, 29, 1, 833);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(29:38) ",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let li;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      if (default_slot)
        default_slot.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(li, file4, 27, 1, 775);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(27:36) ",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let em;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      em = element("em");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      em = claim_element(nodes, "EM", {});
      var em_nodes = children(em);
      if (default_slot)
        default_slot.l(em_nodes);
      em_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(em, file4, 25, 1, 719);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, em, anchor);
      if (default_slot) {
        default_slot.m(em, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(em);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(25:29) ",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let strong;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      strong = element("strong");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      strong = claim_element(nodes, "STRONG", {});
      var strong_nodes = children(strong);
      if (default_slot)
        default_slot.l(strong_nodes);
      strong_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(strong, file4, 23, 1, 662);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, strong, anchor);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(strong);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(23:33) ",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let pre;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      pre = element("pre");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      pre = claim_element(nodes, "PRE", {});
      var pre_nodes = children(pre);
      if (default_slot)
        default_slot.l(pre_nodes);
      pre_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(pre, file4, 21, 1, 607);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, pre, anchor);
      if (default_slot) {
        default_slot.m(pre, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(pre);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(21:39) ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let p;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file4, 19, 1, 550);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(19:36) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let h6;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      h6 = element("h6");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h6 = claim_element(nodes, "H6", {});
      var h6_nodes = children(h6);
      if (default_slot)
        default_slot.l(h6_nodes);
      h6_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h6, file4, 17, 1, 494);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h6, anchor);
      if (default_slot) {
        default_slot.m(h6, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h6);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(17:35) ",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let h5;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      h5 = element("h5");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h5 = claim_element(nodes, "H5", {});
      var h5_nodes = children(h5);
      if (default_slot)
        default_slot.l(h5_nodes);
      h5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h5, file4, 15, 1, 439);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h5, anchor);
      if (default_slot) {
        default_slot.m(h5, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h5);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(15:35) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let h4;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      h4 = element("h4");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h4 = claim_element(nodes, "H4", {});
      var h4_nodes = children(h4);
      if (default_slot)
        default_slot.l(h4_nodes);
      h4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h4, file4, 13, 1, 384);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h4, anchor);
      if (default_slot) {
        default_slot.m(h4, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h4);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(13:35) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let h3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h3 = claim_element(nodes, "H3", {});
      var h3_nodes = children(h3);
      if (default_slot)
        default_slot.l(h3_nodes);
      h3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h3, file4, 11, 1, 329);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h3);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(11:35) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let h2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      h2 = element("h2");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", {});
      var h2_nodes = children(h2);
      if (default_slot)
        default_slot.l(h2_nodes);
      h2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file4, 9, 1, 274);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      if (default_slot) {
        default_slot.m(h2, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(9:35) ",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let h1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      h1 = element("h1");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h1 = claim_element(nodes, "H1", {});
      var h1_nodes = children(h1);
      if (default_slot)
        default_slot.l(h1_nodes);
      h1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h1, file4, 7, 1, 219);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h1, anchor);
      if (default_slot) {
        default_slot.m(h1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h1);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: '(7:0) {#if node.type === \\"heading1\\"}',
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let br;
  const block = {
    c: function create() {
      br = element("br");
      this.h();
    },
    l: function claim(nodes) {
      br = claim_element(nodes, "BR", {});
      this.h();
    },
    h: function hydrate() {
      add_location(br, file4, 47, 17, 1476);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, br, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(br);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(48:2) {#if index > 0}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let t_value = (
    /*line*/
    ctx[3] + ""
  );
  let t;
  let if_block = (
    /*index*/
    ctx[5] > 0 && create_if_block_18(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = text(t_value);
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*node*/
      1 && t_value !== (t_value = /*line*/
      ctx2[3] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: '(46:1) {#each node.text.split(\\"\\n\\") as line, index}',
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(42:1) <PrismicLink field={node.data}>",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block3,
    create_if_block_1,
    create_if_block_2,
    create_if_block_3,
    create_if_block_4,
    create_if_block_5,
    create_if_block_6,
    create_if_block_7,
    create_if_block_8,
    create_if_block_9,
    create_if_block_10,
    create_if_block_11,
    create_if_block_12,
    create_if_block_13,
    create_if_block_14,
    create_if_block_15,
    create_if_block_16,
    create_if_block_17,
    create_else_block
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*node*/
      ctx2[0].type === "heading1"
    )
      return 0;
    if (
      /*node*/
      ctx2[0].type === "heading2"
    )
      return 1;
    if (
      /*node*/
      ctx2[0].type === "heading3"
    )
      return 2;
    if (
      /*node*/
      ctx2[0].type === "heading4"
    )
      return 3;
    if (
      /*node*/
      ctx2[0].type === "heading5"
    )
      return 4;
    if (
      /*node*/
      ctx2[0].type === "heading6"
    )
      return 5;
    if (
      /*node*/
      ctx2[0].type === "paragraph"
    )
      return 6;
    if (
      /*node*/
      ctx2[0].type === "preformatted"
    )
      return 7;
    if (
      /*node*/
      ctx2[0].type === "strong"
    )
      return 8;
    if (
      /*node*/
      ctx2[0].type === "em"
    )
      return 9;
    if (
      /*node*/
      ctx2[0].type === "list-item"
    )
      return 10;
    if (
      /*node*/
      ctx2[0].type === "o-list-item"
    )
      return 11;
    if (
      /*node*/
      ctx2[0].type === "group-list-item"
    )
      return 12;
    if (
      /*node*/
      ctx2[0].type === "group-o-list-item"
    )
      return 13;
    if (
      /*node*/
      ctx2[0].type === "image"
    )
      return 14;
    if (
      /*node*/
      ctx2[0].type === "embed"
    )
      return 15;
    if (
      /*node*/
      ctx2[0].type === "hyperlink"
    )
      return 16;
    if (
      /*node*/
      ctx2[0].type === "label"
    )
      return 17;
    return 18;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DefaultComponent", slots, ["default"]);
  let { node } = $$props;
  $$self.$$.on_mount.push(function() {
    if (node === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<DefaultComponent> was created without expected prop 'node'");
    }
  });
  const writable_props = ["node"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DefaultComponent> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    PrismicEmbed: PrismicEmbed_default,
    PrismicImage: PrismicImage_default,
    PrismicLink: PrismicLink_default,
    node
  });
  $$self.$inject_state = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [node, slots, $$scope];
}
var DefaultComponent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { node: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DefaultComponent",
      options,
      id: create_fragment4.name
    });
  }
  get node() {
    throw new Error("<DefaultComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<DefaultComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DefaultComponent_default = DefaultComponent;

// node_modules/@prismicio/svelte/dist/PrismicRichText/Serialize.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_if_block4(ctx) {
  let serialize;
  let current;
  serialize = new Serialize({
    props: {
      children: (
        /*child*/
        ctx[4].children
      ),
      components: (
        /*components*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(serialize.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(serialize.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(serialize, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const serialize_changes = {};
      if (dirty & /*children*/
      2)
        serialize_changes.children = /*child*/
        ctx2[4].children;
      if (dirty & /*components*/
      1)
        serialize_changes.components = /*components*/
        ctx2[0];
      serialize.$set(serialize_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(serialize.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(serialize.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(serialize, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(18:2) {#if child.children.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*child*/
    ctx[4].children.length > 0 && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*child*/
        ctx2[4].children.length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*children*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(16:1) <svelte:component this={getComponent(child)} node={child.node}>",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*getComponent*/
    ctx[2](
      /*child*/
      ctx[4]
    )
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        node: (
          /*child*/
          ctx2[4].node
        ),
        $$slots: { default: [create_default_slot2] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*children*/
      2 && switch_value !== (switch_value = /*getComponent*/
      ctx2[2](
        /*child*/
        ctx2[4]
      ))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*children*/
        2)
          switch_instance_changes.node = /*child*/
          ctx2[4].node;
        if (dirty & /*$$scope, children, components*/
        131) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(15:0) {#each children as child}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*children*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*getComponent, children, components*/
      7) {
        each_value = ensure_array_like_dev(
          /*children*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Serialize", slots, []);
  let { components = {} } = $$props;
  let { children: children2 } = $$props;
  const CHILD_TYPE_RENAMES = {
    "list-item": "listItem",
    "o-list-item": "oListItem",
    "group-list-item": "list",
    "group-o-list-item": "oList"
  };
  function getComponent(child) {
    return components[CHILD_TYPE_RENAMES[child.type] || child.type] || DefaultComponent_default;
  }
  $$self.$$.on_mount.push(function() {
    if (children2 === void 0 && !("children" in $$props || $$self.$$.bound[$$self.$$.props["children"]])) {
      console.warn("<Serialize> was created without expected prop 'children'");
    }
  });
  const writable_props = ["components", "children"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Serialize> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("components" in $$props2)
      $$invalidate(0, components = $$props2.components);
    if ("children" in $$props2)
      $$invalidate(1, children2 = $$props2.children);
  };
  $$self.$capture_state = () => ({
    DefaultComponent: DefaultComponent_default,
    components,
    children: children2,
    CHILD_TYPE_RENAMES,
    getComponent
  });
  $$self.$inject_state = ($$props2) => {
    if ("components" in $$props2)
      $$invalidate(0, components = $$props2.components);
    if ("children" in $$props2)
      $$invalidate(1, children2 = $$props2.children);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [components, children2, getComponent];
}
var Serialize = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { components: 0, children: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Serialize",
      options,
      id: create_fragment5.name
    });
  }
  get components() {
    throw new Error("<Serialize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set components(value) {
    throw new Error("<Serialize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Serialize>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Serialize>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Serialize_default = Serialize;

// node_modules/@prismicio/svelte/dist/PrismicRichText/PrismicRichText.svelte
function create_fragment6(ctx) {
  let serialize;
  let current;
  serialize = new Serialize_default({
    props: {
      children: (
        /*children*/
        ctx[1]
      ),
      components: (
        /*components*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(serialize.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(serialize.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(serialize, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const serialize_changes = {};
      if (dirty & /*children*/
      2)
        serialize_changes.children = /*children*/
        ctx2[1];
      if (dirty & /*components*/
      1)
        serialize_changes.components = /*components*/
        ctx2[0];
      serialize.$set(serialize_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(serialize.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(serialize.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(serialize, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let children2;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PrismicRichText", slots, []);
  let { field } = $$props;
  let { components = {} } = $$props;
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console.warn("<PrismicRichText> was created without expected prop 'field'");
    }
  });
  const writable_props = ["field", "components"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PrismicRichText> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(2, field = $$props2.field);
    if ("components" in $$props2)
      $$invalidate(0, components = $$props2.components);
  };
  $$self.$capture_state = () => ({
    asTree,
    Serialize: Serialize_default,
    field,
    components,
    children: children2
  });
  $$self.$inject_state = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(2, field = $$props2.field);
    if ("components" in $$props2)
      $$invalidate(0, components = $$props2.components);
    if ("children" in $$props2)
      $$invalidate(1, children2 = $$props2.children);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*field*/
    4) {
      $:
        $$invalidate(1, children2 = asTree(field).children);
    }
  };
  return [components, children2, field];
}
var PrismicRichText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { field: 2, components: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PrismicRichText",
      options,
      id: create_fragment6.name
    });
  }
  get field() {
    throw new Error("<PrismicRichText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error("<PrismicRichText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get components() {
    throw new Error("<PrismicRichText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set components(value) {
    throw new Error("<PrismicRichText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PrismicRichText_default = PrismicRichText;

// node_modules/@prismicio/svelte/package.json
var version = "0.1.2";

// node_modules/@prismicio/svelte/dist/lib/devMsg.js
var devMsg = (slug) => {
  return `https://prismic.dev/msg/react/v${version}/${slug}`;
};

// node_modules/@prismicio/svelte/dist/PrismicText.svelte
var { Error: Error_1, console: console_1 } = globals;
function create_if_block_19(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*fallback*/
        ctx[2]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*fallback*/
        ctx[2]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*fallback*/
      4)
        set_data_dev(
          t,
          /*fallback*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(38:33) ",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let t_value = asText(
    /*field*/
    ctx[0],
    { separator: (
      /*separator*/
      ctx[1]
    ) }
  ) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*field, separator*/
      3 && t_value !== (t_value = asText(
        /*field*/
        ctx2[0],
        { separator: (
          /*separator*/
          ctx2[1]
        ) }
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(36:0) {#if isFilled.richText(field)}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let show_if;
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (dirty & /*field*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!isFilled_exports.richText(
        /*field*/
        ctx2[0]
      );
    if (show_if)
      return create_if_block5;
    if (
      /*fallback*/
      ctx2[2] !== void 0
    )
      return create_if_block_19;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = ["field", "separator", "fallback"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PrismicText", slots, []);
  let { field } = $$props;
  let { separator = void 0 } = $$props;
  let { fallback = void 0 } = $$props;
  if (DEV) {
    if ("className" in $$restProps) {
      console.warn(`[PrismicText] className cannot be passed to <PrismicText> since it renders plain text without a wrapping component. For more details, see ${devMsg("classname-is-not-a-valid-prop")}.`, field);
    }
    if (typeof field === "string") {
      throw new Error(`[PrismicText] The "field" prop only accepts a Rich Text or Title field's value but was provided a different type of field instead (e.g. a Key Text or Select field). You can resolve this error by rendering the field value inline without <PrismicText>. For more details, see ${devMsg("prismictext-works-only-with-rich-text-and-title-fields")}`);
    }
  }
  $$self.$$.on_mount.push(function() {
    if (field === void 0 && !("field" in $$props || $$self.$$.bound[$$self.$$.props["field"]])) {
      console_1.warn("<PrismicText> was created without expected prop 'field'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("field" in $$new_props)
      $$invalidate(0, field = $$new_props.field);
    if ("separator" in $$new_props)
      $$invalidate(1, separator = $$new_props.separator);
    if ("fallback" in $$new_props)
      $$invalidate(2, fallback = $$new_props.fallback);
  };
  $$self.$capture_state = () => ({
    isFilled: isFilled_exports,
    asText,
    DEV,
    devMsg,
    field,
    separator,
    fallback
  });
  $$self.$inject_state = ($$new_props) => {
    if ("field" in $$props)
      $$invalidate(0, field = $$new_props.field);
    if ("separator" in $$props)
      $$invalidate(1, separator = $$new_props.separator);
    if ("fallback" in $$props)
      $$invalidate(2, fallback = $$new_props.fallback);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [field, separator, fallback];
}
var PrismicText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { field: 0, separator: 1, fallback: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PrismicText",
      options,
      id: create_fragment7.name
    });
  }
  get field() {
    throw new Error_1("<PrismicText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set field(value) {
    throw new Error_1("<PrismicText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get separator() {
    throw new Error_1("<PrismicText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set separator(value) {
    throw new Error_1("<PrismicText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fallback() {
    throw new Error_1("<PrismicText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fallback(value) {
    throw new Error_1("<PrismicText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PrismicText_default = PrismicText;

// node_modules/@prismicio/svelte/dist/SliceZone/TodoComponent.svelte
var { console: console_12 } = globals;
var file5 = "node_modules/@prismicio/svelte/dist/SliceZone/TodoComponent.svelte";
function create_if_block6(ctx) {
  let section;
  let t0;
  let t1;
  let t2;
  const block = {
    c: function create() {
      section = element("section");
      t0 = text("Could not find a component for Slice type ");
      t1 = text(
        /*type*/
        ctx[0]
      );
      t2 = text("");
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", {
        "data-slice-zone-todo-component": true,
        "data-slice-type": true
      });
      var section_nodes = children(section);
      t0 = claim_text(section_nodes, "Could not find a component for Slice type ");
      t1 = claim_text(
        section_nodes,
        /*type*/
        ctx[0]
      );
      t2 = claim_text(section_nodes, "");
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(section, "data-slice-zone-todo-component", "");
      attr_dev(
        section,
        "data-slice-type",
        /*type*/
        ctx[0]
      );
      add_location(section, file5, 12, 1, 262);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      append_hydration_dev(section, t0);
      append_hydration_dev(section, t1);
      append_hydration_dev(section, t2);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(section);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(12:0) {#if DEV}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let if_block_anchor;
  let if_block = DEV && create_if_block6(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (DEV)
        if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TodoComponent", slots, []);
  let { slice } = $$props;
  const type = "slice_type" in slice ? slice.slice_type : slice.type;
  if (DEV) {
    console.warn(`[SliceZone] Could not find a component for Slice type "${type}"`, slice);
  }
  $$self.$$.on_mount.push(function() {
    if (slice === void 0 && !("slice" in $$props || $$self.$$.bound[$$self.$$.props["slice"]])) {
      console_12.warn("<TodoComponent> was created without expected prop 'slice'");
    }
  });
  const writable_props = ["slice"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_12.warn(`<TodoComponent> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("slice" in $$props2)
      $$invalidate(1, slice = $$props2.slice);
  };
  $$self.$capture_state = () => ({ DEV, slice, type });
  $$self.$inject_state = ($$props2) => {
    if ("slice" in $$props2)
      $$invalidate(1, slice = $$props2.slice);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [type, slice];
}
var TodoComponent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { slice: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TodoComponent",
      options,
      id: create_fragment8.name
    });
  }
  get slice() {
    throw new Error("<TodoComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slice(value) {
    throw new Error("<TodoComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TodoComponent_default = TodoComponent;

// node_modules/@prismicio/svelte/dist/SliceZone/SliceZone.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  child_ctx[8] = i;
  const constants_0 = "slice_type" in /*slice*/
  child_ctx[4] ? (
    /*slice*/
    child_ctx[4].slice_type
  ) : (
    /*slice*/
    child_ctx[4].type
  );
  child_ctx[5] = constants_0;
  const constants_1 = (
    /*components*/
    child_ctx[1][
      /*type*/
      child_ctx[5]
    ] || /*defaultComponent*/
    child_ctx[3]
  );
  child_ctx[6] = constants_1;
  return child_ctx;
}
function create_else_block2(ctx) {
  let todocomponent;
  let current;
  todocomponent = new TodoComponent_default({
    props: { slice: (
      /*slice*/
      ctx[4]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(todocomponent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(todocomponent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(todocomponent, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const todocomponent_changes = {};
      if (dirty & /*slices*/
      1)
        todocomponent_changes.slice = /*slice*/
        ctx2[4];
      todocomponent.$set(todocomponent_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(todocomponent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(todocomponent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(todocomponent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(29:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*Component*/
    ctx[6]
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        slice: (
          /*slice*/
          ctx2[4]
        ),
        slices: (
          /*slices*/
          ctx2[0]
        ),
        context: (
          /*context*/
          ctx2[2]
        ),
        index: (
          /*index*/
          ctx2[8]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*components, slices, defaultComponent*/
      11 && switch_value !== (switch_value = /*Component*/
      ctx2[6])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*slices*/
        1)
          switch_instance_changes.slice = /*slice*/
          ctx2[4];
        if (dirty & /*slices*/
        1)
          switch_instance_changes.slices = /*slices*/
          ctx2[0];
        if (dirty & /*context*/
        4)
          switch_instance_changes.context = /*context*/
          ctx2[2];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(27:1) {#if Component}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block7, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*Component*/
      ctx2[6]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(24:0) {#each slices as slice, index}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*slices*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*components, slices, defaultComponent, context*/
      15) {
        each_value = ensure_array_like_dev(
          /*slices*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SliceZone", slots, []);
  let { slices = [] } = $$props;
  let { components = {} } = $$props;
  let { context = {} } = $$props;
  let { defaultComponent = void 0 } = $$props;
  const writable_props = ["slices", "components", "context", "defaultComponent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SliceZone> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("slices" in $$props2)
      $$invalidate(0, slices = $$props2.slices);
    if ("components" in $$props2)
      $$invalidate(1, components = $$props2.components);
    if ("context" in $$props2)
      $$invalidate(2, context = $$props2.context);
    if ("defaultComponent" in $$props2)
      $$invalidate(3, defaultComponent = $$props2.defaultComponent);
  };
  $$self.$capture_state = () => ({
    TodoComponent: TodoComponent_default,
    slices,
    components,
    context,
    defaultComponent
  });
  $$self.$inject_state = ($$props2) => {
    if ("slices" in $$props2)
      $$invalidate(0, slices = $$props2.slices);
    if ("components" in $$props2)
      $$invalidate(1, components = $$props2.components);
    if ("context" in $$props2)
      $$invalidate(2, context = $$props2.context);
    if ("defaultComponent" in $$props2)
      $$invalidate(3, defaultComponent = $$props2.defaultComponent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [slices, components, context, defaultComponent];
}
var SliceZone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      slices: 0,
      components: 1,
      context: 2,
      defaultComponent: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SliceZone",
      options,
      id: create_fragment9.name
    });
  }
  get slices() {
    throw new Error("<SliceZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slices(value) {
    throw new Error("<SliceZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get components() {
    throw new Error("<SliceZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set components(value) {
    throw new Error("<SliceZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<SliceZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<SliceZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultComponent() {
    throw new Error("<SliceZone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultComponent(value) {
    throw new Error("<SliceZone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SliceZone_default = SliceZone;
export {
  PrismicEmbed_default as PrismicEmbed,
  PrismicImage_default as PrismicImage,
  PrismicLink_default as PrismicLink,
  PrismicRichText_default as PrismicRichText,
  PrismicText_default as PrismicText,
  SliceZone_default as SliceZone
};
//# sourceMappingURL=@prismicio_svelte.js.map
