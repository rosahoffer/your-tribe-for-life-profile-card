"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupContent = exports.isGroupContent = exports.GroupContentType = exports.GroupLegacy = exports.GroupItemLegacy = exports.GroupItemContent = exports.GroupItemContentType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const LegacyContentCtx_1 = require("../LegacyContentCtx");
const utils_1 = require("../utils");
const nestable_1 = require("./nestable");
exports.GroupItemContentType = "GroupItemContent";
exports.GroupItemContent = t.strict({
    __TYPE__: t.literal(exports.GroupItemContentType),
    value: t.array(t.tuple([t.string, nestable_1.NestableContent])),
});
const itemLegacyReader = t.record(t.string, t.unknown);
const GroupItemLegacy = (ctx) => {
    return new t.Type("GroupItemLegacy", (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.GroupItemContentType, (u) => {
        const parsed = (0, function_1.pipe)(itemLegacyReader.decode(u), fp_ts_1.either.map((items) => {
            const parsedItems = Object.entries(items).reduce((acc, [itemKey, itemValue]) => {
                const itemCtx = (0, LegacyContentCtx_1.getFieldCtx)(itemKey, ctx);
                const result = (0, nestable_1.NestableLegacy)(itemCtx).decode(itemValue);
                if (!result)
                    return acc;
                if ((0, Either_1.isLeft)(result))
                    return acc;
                return [...acc, [itemKey, result.right]];
            }, []);
            return {
                value: parsedItems,
                __TYPE__: exports.GroupItemContentType,
            };
        }));
        return parsed;
    }, (item) => {
        return item.value.reduce((acc, [key, value]) => {
            const itemCtx = (0, LegacyContentCtx_1.getFieldCtx)(key, ctx);
            const encoded = (0, nestable_1.NestableLegacy)(itemCtx).encode(value);
            if (!encoded)
                return acc;
            return {
                content: { ...acc.content, [key]: encoded.content },
                types: { ...acc.types, ...encoded.types },
            };
        }, { content: {}, types: {} });
    });
};
exports.GroupItemLegacy = GroupItemLegacy;
const GroupLegacy = (ctx) => {
    const codecDecode = t.array(t.union([t.null, (0, exports.GroupItemLegacy)(ctx)]));
    const codecEncode = t.array((0, exports.GroupItemLegacy)(ctx));
    return new t.Type("GroupLegacy", exports.isGroupContent, (items) => {
        return (0, function_1.pipe)(codecDecode.decode(items), fp_ts_1.either.map((parsedItems) => {
            return {
                value: parsedItems.map((i) => {
                    if (i === null) {
                        return { __TYPE__: exports.GroupItemContentType, value: [] };
                    }
                    else
                        return i;
                }),
                __TYPE__: exports.GroupContentType,
            };
        }));
    }, (g) => {
        const res = codecEncode.encode(g.value);
        return {
            content: res.map((block) => block.content),
            types: res.reduce((acc, block) => {
                return { ...acc, ...block.types };
            }, { [ctx.keyOfType]: "Group" }),
        };
    });
};
exports.GroupLegacy = GroupLegacy;
exports.GroupContentType = "GroupContentType";
const isGroupContent = (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.GroupContentType;
exports.isGroupContent = isGroupContent;
exports.GroupContent = t.strict({
    __TYPE__: t.literal(exports.GroupContentType),
    value: t.array(exports.GroupItemContent),
});
