"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlicesItemLegacy = exports.SliceItemContent = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const function_2 = require("../../../validators/function");
const LegacyContentCtx_1 = require("../../LegacyContentCtx");
const Slice_1 = require("./Slice");
const CompositeSliceContent_1 = require("./Slice/CompositeSliceContent");
const SharedSliceContent_1 = require("./Slice/SharedSliceContent");
const SimpleSliceContent_1 = require("./Slice/SimpleSliceContent");
exports.SliceItemContent = t.type({
    key: t.string,
    name: t.string,
    maybeLabel: t.union([t.string, t.undefined]),
    widget: Slice_1.SliceContent,
});
const itemLegacyReader = t.exact(t.intersection([
    t.type({
        key: t.string,
        value: t.unknown,
    }),
    t.partial({
        label: (0, function_2.nullable)(t.string),
    }),
]));
const SlicesItemLegacy = (ctx) => {
    return new t.Type("SlicesItemLegacy", (u) => ((0, SharedSliceContent_1.isSharedSliceContent)(u.widget),
        (0, CompositeSliceContent_1.isCompositeSliceContent)(u.widget),
        (0, SimpleSliceContent_1.isSimpleSliceContent)(u.widget)), (sliceItem, context) => {
        return (0, function_1.pipe)(itemLegacyReader.decode(sliceItem), fp_ts_1.either.chain((parsedSlice) => {
            var _a;
            const stopIdx = parsedSlice.key.indexOf("$");
            const sliceName = parsedSlice.key.substring(0, stopIdx > 0 ? stopIdx : undefined);
            const itemCtx = (0, LegacyContentCtx_1.getFieldCtx)(sliceName, ctx);
            const item = (0, Slice_1.SliceLegacy)(itemCtx).decode(parsedSlice.value);
            if (!item || (0, Either_1.isLeft)(item))
                return t.failure(sliceItem, context);
            return t.success({
                key: parsedSlice.key,
                name: sliceName,
                maybeLabel: (_a = parsedSlice.label) !== null && _a !== void 0 ? _a : undefined,
                widget: item.right,
            });
        }));
    }, (sItem) => {
        const itemCtx = (0, LegacyContentCtx_1.getFieldCtx)(sItem.name, ctx);
        const result = (0, Slice_1.SliceLegacy)(itemCtx).encode(sItem.widget);
        return {
            content: {
                key: sItem.key,
                label: sItem.maybeLabel,
                value: (result === null || result === void 0 ? void 0 : result.content) || {},
            },
            types: (result === null || result === void 0 ? void 0 : result.types) || {},
        };
    });
};
exports.SlicesItemLegacy = SlicesItemLegacy;
