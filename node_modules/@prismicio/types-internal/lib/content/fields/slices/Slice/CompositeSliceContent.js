"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompositeSliceContent = exports.CompositeSliceLegacy = exports.isCompositeSliceContent = exports.CompositeSliceContentType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const LegacyContentCtx_1 = require("../../../LegacyContentCtx");
const utils_1 = require("../../../utils");
const nestable_1 = require("../../nestable");
const RepeatableContent_1 = require("./RepeatableContent");
exports.CompositeSliceContentType = "CompositeSliceContent";
const isCompositeSliceContent = (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.CompositeSliceContentType;
exports.isCompositeSliceContent = isCompositeSliceContent;
const legacyReader = t.exact(t.partial({
    repeat: t.array(t.unknown),
    "non-repeat": t.UnknownRecord,
}));
const CompositeSliceLegacy = (ctx) => {
    return new t.Type("CompositeSliceLegacy", exports.isCompositeSliceContent, (slice) => {
        return (0, function_1.pipe)(legacyReader.decode(slice), fp_ts_1.either.map((parsedSlice) => {
            const repeat = (() => {
                const itemsCtx = (0, LegacyContentCtx_1.getFieldCtx)("repeat", ctx);
                const result = (0, RepeatableContent_1.RepeatableWidgetsLegacy)(itemsCtx).decode(parsedSlice.repeat);
                if (!result || (0, Either_1.isLeft)(result))
                    return;
                return result.right;
            })() || [];
            const nonRepeat = Object.entries(parsedSlice["non-repeat"] || {}).reduce((acc, [key, value]) => {
                const fieldCtx = (0, LegacyContentCtx_1.getFieldCtx)(key, ctx, ["non-repeat"]);
                if (!fieldCtx)
                    return acc;
                const result = (0, nestable_1.NestableLegacy)(fieldCtx).decode(value);
                if (!result)
                    return acc;
                if ((0, Either_1.isLeft)(result))
                    return acc;
                return { ...acc, [key]: result.right };
            }, {});
            return {
                nonRepeat,
                repeat,
                __TYPE__: exports.CompositeSliceContentType,
            };
        }));
    }, (s) => {
        const nonRepeat = Object.entries(s.nonRepeat).reduce((acc, [key, value]) => {
            const FieldCtx = (0, LegacyContentCtx_1.getFieldCtx)(key, ctx, ["non-repeat"]);
            const result = (0, nestable_1.NestableLegacy)(FieldCtx).encode(value);
            if (!result)
                return acc;
            return {
                content: { ...acc.content, [key]: result.content },
                types: { ...acc.types, ...result.types },
            };
        }, { content: {}, types: {} });
        const repeat = (() => {
            const itemsCtx = (0, LegacyContentCtx_1.getFieldCtx)("repeat", ctx);
            const result = (0, RepeatableContent_1.RepeatableWidgetsLegacy)(itemsCtx).encode(s.repeat);
            return result;
        })() || [];
        return {
            content: {
                "non-repeat": nonRepeat.content,
                repeat: repeat.map((i) => i.content),
            },
            types: {
                [ctx.keyOfType]: "Slice",
                ...nonRepeat.types,
                ...repeat.reduce((acc, i) => ({ ...acc, ...i.types }), {}),
            },
        };
    });
};
exports.CompositeSliceLegacy = CompositeSliceLegacy;
exports.CompositeSliceContent = t.strict({
    __TYPE__: t.literal(exports.CompositeSliceContentType),
    nonRepeat: t.record(t.string, nestable_1.NestableContent),
    repeat: RepeatableContent_1.RepeatableWidgets,
});
