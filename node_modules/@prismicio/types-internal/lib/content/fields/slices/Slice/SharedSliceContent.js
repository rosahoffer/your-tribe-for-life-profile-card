"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedSliceContent = exports.SharedSliceLegacy = exports.isSharedSliceContent = exports.SharedSliceContentType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const io_ts_types_1 = require("io-ts-types");
const LegacyContentCtx_1 = require("../../../LegacyContentCtx");
const utils_1 = require("../../../utils");
const nestable_1 = require("../../nestable");
const RepeatableContent_1 = require("./RepeatableContent");
exports.SharedSliceContentType = "SharedSliceContent";
const isSharedSliceContent = (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.SharedSliceContentType;
exports.isSharedSliceContent = isSharedSliceContent;
const legacyReader = t.exact(t.type({
    variation: t.string,
    items: (0, io_ts_types_1.withFallback)(t.array(t.unknown), []),
    primary: (0, io_ts_types_1.withFallback)(t.UnknownRecord, {}),
}));
const SharedSliceLegacy = (ctx) => {
    return new t.Type("SharedSliceLegacy", exports.isSharedSliceContent, (slice) => {
        return (0, function_1.pipe)(legacyReader.decode(slice), fp_ts_1.either.map((parsedSlice) => {
            const items = (() => {
                const itemsCtx = (0, LegacyContentCtx_1.getFieldCtx)("items", ctx, [
                    "variations",
                    parsedSlice.variation,
                ]);
                const result = (0, RepeatableContent_1.RepeatableWidgetsLegacy)(itemsCtx).decode(parsedSlice.items);
                if (!result || (0, Either_1.isLeft)(result))
                    return;
                return result.right;
            })() || [];
            const primary = Object.entries(parsedSlice.primary).reduce((acc, [key, value]) => {
                const FieldCtx = (0, LegacyContentCtx_1.getFieldCtx)(key, ctx, [
                    "variations",
                    parsedSlice.variation,
                    "primary",
                ]);
                const result = (0, nestable_1.NestableLegacy)(FieldCtx).decode(value);
                if (!result)
                    return acc;
                if ((0, Either_1.isLeft)(result))
                    return acc;
                return { ...acc, [key]: result.right };
            }, {});
            return {
                variation: parsedSlice.variation,
                primary,
                items,
                __TYPE__: exports.SharedSliceContentType,
            };
        }));
    }, (s) => {
        const primary = Object.entries(s.primary).reduce((acc, [key, value]) => {
            const FieldCtx = (0, LegacyContentCtx_1.getFieldCtx)(key, ctx, [
                "variations",
                s.variation,
                "primary",
            ]);
            const result = (0, nestable_1.NestableLegacy)(FieldCtx).encode(value);
            if (!result)
                return acc;
            return {
                content: { ...acc.content, [key]: result.content },
                types: { ...acc.types, ...result.types },
            };
        }, { content: {}, types: {} });
        const items = (() => {
            const itemsCtx = (0, LegacyContentCtx_1.getFieldCtx)("items", ctx, [
                "variations",
                s.variation,
            ]);
            const result = (0, RepeatableContent_1.RepeatableWidgetsLegacy)(itemsCtx).encode(s.items);
            return result;
        })() || [];
        return {
            content: {
                primary: primary.content,
                items: items.map((i) => i.content),
                variation: s.variation,
            },
            types: {
                [ctx.keyOfType]: "SharedSlice",
                ...primary.types,
                ...items.reduce((acc, i) => ({ ...acc, ...i.types }), {}),
            },
        };
    });
};
exports.SharedSliceLegacy = SharedSliceLegacy;
exports.SharedSliceContent = t.strict({
    __TYPE__: t.literal(exports.SharedSliceContentType),
    variation: t.string,
    primary: t.record(t.string, nestable_1.NestableContent),
    items: RepeatableContent_1.RepeatableWidgets,
});
