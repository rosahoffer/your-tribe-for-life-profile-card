"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = exports.BlockLegacy = exports.TextBlock = exports.checkEmbedBlock = exports.EmbedBlock = exports.checkImageBlock = exports.ImageBlock = exports.ValidatedMetas = exports.Span = exports.Meta = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const nestable_1 = require("../../../../customtypes/widgets/nestable");
const validators_1 = require("../../../../validators");
const function_2 = require("../../../../validators/function");
const EmbedContent_1 = require("../EmbedContent");
const ImageContent_1 = require("../ImageContent");
const LinkContent_1 = require("../LinkContent");
exports.Meta = t.exact(t.intersection([
    t.partial({
        data: t.unknown,
    }),
    t.type({
        start: t.number,
        end: t.number,
        type: t.union([nestable_1.RichTextNodeTypeCodec, t.literal("label")]),
    }),
]));
// export alias for code clarity
exports.Span = exports.Meta;
const ValidatedMetas = (linkCodec) => new t.Type("ValidatedMetas", (metas) => Array.isArray(metas) && metas.every(exports.Meta.is), (metas, c) => {
    if (Array.isArray(metas)) {
        const res = metas
            .reduce((acc, maybeMeta) => {
            const maybeDecodedMeta = exports.Meta.decode(maybeMeta);
            if ((0, Either_1.isRight)(maybeDecodedMeta)) {
                const meta = maybeDecodedMeta.right;
                // if it's an hyperlink it should have data validated as link otherwise we don't care and keep the meta
                if (meta.data && meta.type === "hyperlink") {
                    const decoded = linkCodec.decode(meta.data);
                    if ((0, Either_1.isLeft)(decoded))
                        return acc;
                    return [...acc, { ...meta, data: decoded.right }];
                }
                else if (meta.type !== "hyperlink") {
                    return [...acc, meta];
                }
            }
            return acc;
        }, [])
            .sort((m1, m2) => m1.start - m2.start);
        return t.success(res);
    }
    else
        return t.failure(metas, c);
}, (m) => {
    return m.reduce((acc, meta) => {
        if (meta.type === "hyperlink" && meta.data) {
            // since the Span data are typed as unknown we have to redecode for type safety and then encode to either new format or legacy.
            const decoded = linkCodec.decode(meta.data);
            if ((0, Either_1.isLeft)(decoded))
                return acc;
            return [...acc, { ...meta, data: linkCodec.encode(decoded.right) }];
        }
        return [...acc, exports.Meta.encode(meta)];
    }, []);
});
exports.ValidatedMetas = ValidatedMetas;
const ImageBlockCodec = (linkCodec) => t.exact(t.intersection([
    t.type({
        type: t.literal(nestable_1.RichTextNodeType.image),
        data: t.intersection([
            ImageContent_1.ImageContentView,
            t.partial({
                linkTo: (0, function_2.nullable)(linkCodec),
            }),
        ]),
    }),
    t.partial({
        label: validators_1.StringOrNull,
        direction: validators_1.StringOrNull,
    }),
]));
exports.ImageBlock = ImageBlockCodec(LinkContent_1.Link);
const ImageBlockLegacy = ImageBlockCodec(LinkContent_1.LinkLegacy);
function checkImageBlock(block) {
    return block.type === nestable_1.RichTextNodeType.image;
}
exports.checkImageBlock = checkImageBlock;
const embedBlockLegacyCodec = t.exact(t.intersection([
    t.type({
        type: t.literal(nestable_1.RichTextNodeType.embed),
        data: t.unknown,
    }),
    t.partial({
        label: validators_1.StringOrNull,
        direction: validators_1.StringOrNull,
    }),
]));
const EmbedBlockLegacy = new t.Type("EmbedBlockLegacy", (u) => u.type === "embed", (block) => (0, function_1.pipe)(embedBlockLegacyCodec.decode(block), fp_ts_1.either.chain((decodedBlock) => {
    return fp_ts_1.either.map((decodedData) => {
        return [decodedBlock, decodedData];
    })(EmbedContent_1.EmbedContentLegacy.decode(decodedBlock.data));
}), fp_ts_1.either.map(([block, parsedData]) => {
    return exports.EmbedBlock.encode({
        ...block,
        data: {
            ...parsedData,
            __TYPE__: EmbedContent_1.EmbedContentType,
            all: block.data,
        },
    });
})), (embedBlock) => {
    return {
        ...embedBlockLegacyCodec.encode(embedBlock),
        data: EmbedContent_1.EmbedContentLegacy.encode(embedBlock.data),
    };
});
exports.EmbedBlock = t.exact(t.intersection([
    t.type({
        type: t.literal(nestable_1.RichTextNodeType.embed),
        data: EmbedContent_1.EmbedContent,
    }),
    t.partial({
        label: validators_1.StringOrNull,
        direction: validators_1.StringOrNull,
    }),
]));
function checkEmbedBlock(block) {
    return block.type === nestable_1.RichTextNodeType.embed;
}
exports.checkEmbedBlock = checkEmbedBlock;
const TextBlockCodec = (linkCodec) => t.exact(t.intersection([
    t.type({
        type: (0, function_2.refineType)(nestable_1.RichTextNodeTypeCodec, `string which isn't ${nestable_1.RichTextNodeType.image} ${nestable_1.RichTextNodeType.embed}`, (s) => s !== nestable_1.RichTextNodeType.image && s !== nestable_1.RichTextNodeType.embed),
        content: t.intersection([
            t.type({
                text: t.string,
            }),
            t.partial({
                spans: (0, exports.ValidatedMetas)(linkCodec),
            }),
        ]),
    }),
    t.partial({
        label: t.string,
        direction: t.string,
    }),
]));
exports.TextBlock = TextBlockCodec(LinkContent_1.Link);
const TextBlockLegacy = TextBlockCodec(LinkContent_1.LinkLegacy);
const legacyBlockCodec = t.union([
    EmbedBlockLegacy,
    ImageBlockLegacy,
    TextBlockLegacy,
]);
exports.BlockLegacy = new t.Type("BlockLegacy", (u) => EmbedBlockLegacy.is(u) || ImageBlockLegacy.is(u) || TextBlockLegacy.is(u), (legacyBlock) => legacyBlockCodec.decode(legacyBlock), (block) => {
    return (() => {
        if (exports.ImageBlock.is(block))
            return ImageBlockLegacy.encode(block);
        else if (exports.EmbedBlock.is(block))
            return EmbedBlockLegacy.encode(block);
        else
            return TextBlockLegacy.encode(block);
    })();
});
exports.Block = t.union([exports.ImageBlock, exports.EmbedBlock, exports.TextBlock]);
