import { either } from "fp-ts"
import { isLeft, isRight } from "fp-ts/lib/Either"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import { WidgetKey } from "../common"
import { WidgetContent, WidgetLegacy } from "./fields"
import {
	defaultCtx,
	FieldOrSliceType,
	LegacyContentCtx,
	WithTypes,
} from "./LegacyContentCtx"

export const Document = t.record(WidgetKey, WidgetContent)
export type Document = t.TypeOf<typeof Document>

const legacyDocReader = t.record(WidgetKey, t.unknown)
type DocumentLegacy = t.TypeOf<typeof legacyDocReader>

const DocumentLegacyCodec = (allTypes?: LegacyContentCtx["allTypes"]) => {
	return new t.Type<Document, WithTypes<DocumentLegacy>, unknown>(
		"Document",
		(u): u is Document => !!u && typeof u === "object",
		(doc) => {
			return pipe(
				legacyDocReader.decode(doc),
				either.map((parsedDoc) => {
					return Object.entries(parsedDoc).reduce(
						(acc, [widgetKey, widgetValue]) => {
							const widgetCtx = defaultCtx(widgetKey, allTypes)
							const parsedW = WidgetLegacy(widgetCtx).decode(widgetValue)
							if (!parsedW || isLeft(parsedW)) return acc

							return { ...acc, [widgetKey]: parsedW.right }
						},
						{},
					)
				}),
			)
		},
		(g: Document) => {
			return Object.entries(g).reduce(
				(acc, [key, value]) => {
					const widgetCtx = defaultCtx(key, allTypes)
					const result = WidgetLegacy(widgetCtx).encode(value)
					if (!result) return acc

					return {
						content: { ...acc.content, [key]: result.content },
						types: { ...acc.types, ...result.types },
					}
				},
				{ content: {}, types: {} },
			)
		},
	)
}

function extractMetadata(data: { [p: string]: unknown }): {
	types: Map<string, FieldOrSliceType>
	widgets: Partial<Record<WidgetKey, unknown>>
	slugs: ReadonlyArray<string>
	uid: string | undefined
} {
	const fields: [string, unknown][] = Object.entries(data)

	const { types, widgets } = fields.reduce(
		(acc, [k, v]) => {
			if (k.endsWith("_TYPE")) {
				const decodedValue = FieldOrSliceType.decode(v)
				if (isRight(decodedValue)) {
					return {
						...acc,
						types: acc.types.set(
							k.substring(0, k.length - 5),
							decodedValue.right,
						),
					}
				}
			}
			if (!k.endsWith("_POSITION") && !k.endsWith("_TYPE")) {
				return {
					...acc,
					widgets: {
						...acc.widgets,
						[k]: v,
					},
				}
			}
			return acc
		},
		{
			types: new Map<string, FieldOrSliceType>(),
			widgets: {},
		},
	)

	const slugs = (data["slugs_INTERNAL"] as string[]) || []
	const uid = data["uid"] as string | undefined

	return {
		widgets,
		types,
		uid,
		slugs,
	}
}

function parseLegacyDocument(legacyDoc: unknown): Document | undefined {
	const result = pipe(
		// ensure it's the right document format first
		t.record(WidgetKey, t.unknown).decode(legacyDoc),
		either.chain((doc) => {
			// extract all metadata, meaning all _TYPES keys from legacy format + the widgets as unknown
			const { types, widgets } = extractMetadata(doc)
			// parse the actual widgets
			return DocumentLegacyCodec(types).decode(widgets)
		}),
	)

	return isLeft(result) ? undefined : result.right
}

function encodeToLegacyDocument(document: Document): DocumentLegacy {
	const encoded = DocumentLegacyCodec().encode(document)
	return { ...encoded.content, ...encoded.types }
}

export const DocumentLegacy = {
	_codec: DocumentLegacyCodec,
	extractMetadata,
	parse: parseLegacyDocument,
	encode: encodeToLegacyDocument,
}
