import { either } from "fp-ts"
import { isLeft } from "fp-ts/lib/Either"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import {
	getFieldCtx,
	LegacyContentCtx,
	WithTypes,
} from "../../../LegacyContentCtx"
import { hasContentType } from "../../../utils"
import { NestableContent, NestableLegacy } from "../../nestable"
import { RepeatableWidgets, RepeatableWidgetsLegacy } from "./RepeatableContent"

export const CompositeSliceContentType = "CompositeSliceContent"

export const isCompositeSliceContent = (
	u: unknown,
): u is CompositeSliceContent =>
	hasContentType(u) && u.__TYPE__ === CompositeSliceContentType

const legacyReader = t.exact(
	t.partial({
		repeat: t.array(t.unknown),
		"non-repeat": t.UnknownRecord,
	}),
)
type CompositeSliceLegacy = t.TypeOf<typeof legacyReader>

export const CompositeSliceLegacy = (ctx: LegacyContentCtx) => {
	return new t.Type<
		CompositeSliceContent,
		WithTypes<CompositeSliceLegacy>,
		unknown
	>(
		"CompositeSliceLegacy",
		isCompositeSliceContent,
		(slice) => {
			return pipe(
				legacyReader.decode(slice),
				either.map((parsedSlice) => {
					const repeat =
						(() => {
							const itemsCtx = getFieldCtx("repeat", ctx)
							const result = RepeatableWidgetsLegacy(itemsCtx).decode(
								parsedSlice.repeat,
							)
							if (!result || isLeft(result)) return
							return result.right
						})() || []

					const nonRepeat = Object.entries(
						parsedSlice["non-repeat"] || {},
					).reduce<Record<string, NestableContent>>((acc, [key, value]) => {
						const fieldCtx = getFieldCtx(key, ctx, ["non-repeat"])
						if (!fieldCtx) return acc

						const result = NestableLegacy(fieldCtx).decode(value)
						if (!result) return acc

						if (isLeft(result)) return acc
						return { ...acc, [key]: result.right }
					}, {})

					return {
						nonRepeat,
						repeat,
						__TYPE__: CompositeSliceContentType,
					}
				}),
			)
		},
		(s: CompositeSliceContent) => {
			const nonRepeat = Object.entries(s.nonRepeat).reduce<
				WithTypes<{ [key: string]: unknown }>
			>(
				(acc, [key, value]) => {
					const FieldCtx = getFieldCtx(key, ctx, ["non-repeat"])

					const result = NestableLegacy(FieldCtx).encode(value)
					if (!result) return acc

					return {
						content: { ...acc.content, [key]: result.content },
						types: { ...acc.types, ...result.types },
					}
				},
				{ content: {}, types: {} },
			)

			const repeat =
				(() => {
					const itemsCtx = getFieldCtx("repeat", ctx)
					const result = RepeatableWidgetsLegacy(itemsCtx).encode(s.repeat)
					return result
				})() || []

			return {
				content: {
					"non-repeat": nonRepeat.content,
					repeat: repeat.map((i) => i.content),
				},
				types: {
					[ctx.keyOfType]: "Slice",
					...nonRepeat.types,
					...repeat.reduce((acc, i) => ({ ...acc, ...i.types }), {}),
				},
			}
		},
	)
}

export const CompositeSliceContent = t.strict({
	__TYPE__: t.literal(CompositeSliceContentType),
	nonRepeat: t.record(t.string, NestableContent),
	repeat: RepeatableWidgets,
})

export type CompositeSliceContent = t.TypeOf<typeof CompositeSliceContent>
