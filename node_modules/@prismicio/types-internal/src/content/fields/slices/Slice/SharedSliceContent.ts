import { either } from "fp-ts"
import { isLeft } from "fp-ts/lib/Either"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"
import { withFallback } from "io-ts-types"

import {
	getFieldCtx,
	LegacyContentCtx,
	WithTypes,
} from "../../../LegacyContentCtx"
import { hasContentType } from "../../../utils"
import { NestableContent, NestableLegacy } from "../../nestable"
import { RepeatableWidgets, RepeatableWidgetsLegacy } from "./RepeatableContent"

export const SharedSliceContentType = "SharedSliceContent"

export const isSharedSliceContent = (u: unknown): u is SharedSliceContent =>
	hasContentType(u) && u.__TYPE__ === SharedSliceContentType

const legacyReader = t.exact(
	t.type({
		variation: t.string,
		items: withFallback(t.array(t.unknown), []),
		primary: withFallback(t.UnknownRecord, {}),
	}),
)
type SharedSliceLegacy = t.TypeOf<typeof legacyReader>

export const SharedSliceLegacy = (ctx: LegacyContentCtx) => {
	return new t.Type<SharedSliceContent, WithTypes<SharedSliceLegacy>, unknown>(
		"SharedSliceLegacy",
		isSharedSliceContent,
		(slice) => {
			return pipe(
				legacyReader.decode(slice),
				either.map((parsedSlice) => {
					const items =
						(() => {
							const itemsCtx = getFieldCtx("items", ctx, [
								"variations",
								parsedSlice.variation,
							])
							const result = RepeatableWidgetsLegacy(itemsCtx).decode(
								parsedSlice.items,
							)
							if (!result || isLeft(result)) return
							return result.right
						})() || []

					const primary = Object.entries(parsedSlice.primary).reduce<
						Record<string, NestableContent>
					>((acc, [key, value]) => {
						const FieldCtx = getFieldCtx(key, ctx, [
							"variations",
							parsedSlice.variation,
							"primary",
						])

						const result = NestableLegacy(FieldCtx).decode(value)
						if (!result) return acc

						if (isLeft(result)) return acc
						return { ...acc, [key]: result.right }
					}, {})

					return {
						variation: parsedSlice.variation,
						primary,
						items,
						__TYPE__: SharedSliceContentType,
					}
				}),
			)
		},
		(s: SharedSliceContent) => {
			const primary = Object.entries(s.primary).reduce<
				WithTypes<Record<string, unknown>>
			>(
				(acc, [key, value]) => {
					const FieldCtx = getFieldCtx(key, ctx, [
						"variations",
						s.variation,
						"primary",
					])

					const result = NestableLegacy(FieldCtx).encode(value)
					if (!result) return acc

					return {
						content: { ...acc.content, [key]: result.content },
						types: { ...acc.types, ...result.types },
					}
				},
				{ content: {}, types: {} },
			)

			const items =
				(() => {
					const itemsCtx = getFieldCtx("items", ctx, [
						"variations",
						s.variation,
					])
					const result = RepeatableWidgetsLegacy(itemsCtx).encode(s.items)
					return result
				})() || []

			return {
				content: {
					primary: primary.content,
					items: items.map((i) => i.content),
					variation: s.variation,
				},
				types: {
					[ctx.keyOfType]: "SharedSlice",
					...primary.types,
					...items.reduce((acc, i) => ({ ...acc, ...i.types }), {}),
				},
			}
		},
	)
}

export const SharedSliceContent = t.strict({
	__TYPE__: t.literal(SharedSliceContentType),
	variation: t.string,
	primary: t.record(t.string, NestableContent),
	items: RepeatableWidgets,
})
export type SharedSliceContent = t.TypeOf<typeof SharedSliceContent>
