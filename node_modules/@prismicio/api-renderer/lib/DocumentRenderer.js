"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const widgets_1 = require("@prismicio/types-internal/lib/documents/widgets");
const slices_1 = require("@prismicio/types-internal/lib/documents/widgets/slices");
const models_1 = require("./models");
const utils_1 = require("./utils");
const widgets_2 = require("./widgets");
const SlicesRenderer_1 = tslib_1.__importDefault(require("./widgets/slices/SlicesRenderer"));
const DEPRECATED_ARRAY_REGEX = /(\w+)\[\d+]/;
function i18nWriter(doc) {
    const result = {
        id: doc.id,
        type: doc.typ,
        lang: doc.language,
    };
    if (doc.uid) {
        return {
            ...result,
            uid: doc.uid,
        };
    }
    return result;
}
function renderWidgetV1(ctx) {
    return (content, fetchOpt) => {
        if (content.__TYPE__ === widgets_1.EmptyContentType) {
            return undefined;
        }
        else if (widgets_1.StaticWidgetContent.is(content) && !widgets_1.EmptyContent.is(content)) {
            return (0, widgets_2.StaticWidgetRenderer)(ctx).renderV1(content, models_1.Fetch.extractGroupOrFieldIfAny(fetchOpt));
        }
        else {
            return (0, SlicesRenderer_1.default)(ctx).renderV1(content, models_1.Fetch.extractSliceFetchIfAny(fetchOpt));
        }
    };
}
function renderWidgetsV1(ctx) {
    return (doc, content, fetch) => {
        const renderedContent = {};
        for (const [key, widgetContent] of content) {
            if (key !== "uid") {
                const deprecatedArray = key.match(DEPRECATED_ARRAY_REGEX);
                const isDeprecatedArray = deprecatedArray && deprecatedArray[1];
                // we cast to string since the TS compiler doesn't understand than if `deprecatedArray` exists, the regexp matched so `deprecatedArray[1]` is defined.
                const newKey = (isDeprecatedArray ? deprecatedArray[1] : key);
                const maybeContent = isDeprecatedArray ? renderedContent[newKey] : undefined;
                if (fetch !== undefined) {
                    const field = fetch.fields[key];
                    if (field !== undefined) {
                        if (isDeprecatedArray) {
                            renderedContent[newKey] = Array.isArray(maybeContent)
                                ? [...maybeContent, renderWidgetV1(ctx)(widgetContent, field)]
                                : [renderWidgetV1(ctx)(widgetContent, field)];
                        }
                        else {
                            renderedContent[newKey] = renderWidgetV1(ctx)(widgetContent, field);
                        }
                    }
                }
                else {
                    if (isDeprecatedArray) {
                        renderedContent[newKey] = Array.isArray(maybeContent)
                            ? [...maybeContent, renderWidgetV1(ctx)(widgetContent, undefined)]
                            : [renderWidgetV1(ctx)(widgetContent, undefined)];
                    }
                    else {
                        renderedContent[newKey] = renderWidgetV1(ctx)(widgetContent, undefined);
                    }
                }
            }
        }
        return { [doc.type]: renderedContent };
    };
}
function renderV1(ctx) {
    return (doc, content, masterLang, searchURL, i18n, withMeta, brokenRoute, linkResolver, fetchDoc) => {
        var _a, _b;
        const relatedDocs = (i18n[doc.groupLangId] || [])
            .filter((relatedDocument) => relatedDocument.id !== doc.id)
            .map((relatedDocument) => i18nWriter(relatedDocument));
        const widgets = renderWidgetsV1(ctx)(doc, content, fetchDoc);
        return {
            id: doc.id,
            uid: (_a = doc.data.uid) !== null && _a !== void 0 ? _a : null,
            url: (_b = ctx.LinkResolver.buildUrl({
                linkResolver: linkResolver,
                pageType: doc.type,
                masterLang,
                brokenRoute,
                doc,
            })) !== null && _b !== void 0 ? _b : null,
            type: doc.type,
            href: ctx.urlRewriter.enforceCDN(searchURL),
            tags: doc.tags,
            first_publication_date: doc.first_publication_date ? (0, utils_1.formatDateTime)(doc.first_publication_date) : null,
            last_publication_date: doc.last_publication_date ? (0, utils_1.formatDateTime)(doc.last_publication_date) : null,
            slugs: doc.data.slugs,
            linked_documents: [],
            lang: doc.language,
            alternate_languages: relatedDocs,
            data: widgets,
            ...(withMeta ? doc.metadata : {}),
        };
    };
}
function renderWidgetV2(ctx) {
    return (mask, content, fetchOpt) => {
        if (content.__TYPE__ === slices_1.SlicesContentType && mask.__TYPE__ === models_1.SlicesDefType) {
            return (0, SlicesRenderer_1.default)(ctx).renderV2(mask, content, models_1.Fetch.extractSliceFetchIfAny(fetchOpt));
        }
        else if (widgets_1.StaticWidgetContent.is(content) && (0, models_1.isStaticFieldDef)(mask)) {
            return (0, widgets_2.StaticWidgetRenderer)(ctx).renderV2(mask, content, models_1.Fetch.extractGroupOrFieldIfAny(fetchOpt));
        }
        else {
            return renderDefaultWidget(ctx)(mask);
        }
    };
}
function renderV2(ctx) {
    return (mask, doc, masterLang, content, searchURL, i18n, withMeta, brokenRoute, linkResolver, fetchDoc) => {
        var _a, _b;
        const widgets = mask.definitions
            .filter((def) => Object.keys(def).every((v) => v !== "uid"))
            .map((widgetDef) => {
            const filteredWidget = Object.entries(widgetDef).find(([k]) => k !== "config"); // name[0] is the SimpleFieldDef name i.e. the widget name and apiId the api id of the field
            const name = filteredWidget && {
                apiId: filteredWidget[1],
            };
            if (name) {
                const correspondingContent = content.find(([id]) => id === name.apiId);
                const encodedWidgetDef = models_1.WidgetDef.encode(widgetDef);
                const fetchField = fetchDoc === null || fetchDoc === void 0 ? void 0 : fetchDoc.fields[name.apiId];
                const deprecatedArray = name.apiId.match(DEPRECATED_ARRAY_REGEX);
                const isDeprecatedArray = Boolean(deprecatedArray && deprecatedArray[1]);
                const newKey = (isDeprecatedArray ? deprecatedArray[1] : name.apiId);
                if (correspondingContent) {
                    if (fetchDoc === undefined || fetchField !== undefined) {
                        return [
                            newKey,
                            renderWidgetV2(ctx)(encodedWidgetDef, correspondingContent[1], fetchField),
                            isDeprecatedArray,
                        ];
                    }
                    else {
                        return undefined;
                    }
                }
                else {
                    //TODO: not sure about that
                    if (fetchDoc === undefined || fetchField !== undefined) {
                        return [newKey, renderDefaultWidget(ctx)(encodedWidgetDef), isDeprecatedArray];
                    }
                    else {
                        return undefined;
                    }
                }
            }
            throw new Error(""); // todo better error handling
        })
            .reduce((acc, maybeWidget) => {
            if (maybeWidget) {
                const [key, widget, isDeprecatedArray] = maybeWidget;
                if (isDeprecatedArray) {
                    const maybeContent = acc[key];
                    if (maybeContent) {
                        if (Array.isArray(maybeContent)) {
                            return {
                                ...acc,
                                [key]: [...maybeContent, widget],
                            };
                        }
                        else {
                            throw new Error(`[UNEXPECTED ERROR] ${JSON.stringify(maybeContent)} should be an Array`);
                        }
                    }
                    return {
                        ...acc,
                        [key]: [widget],
                    };
                }
                return {
                    ...acc,
                    [key]: widget,
                };
            }
            return acc;
        }, {});
        const relatedDocs = (i18n[doc.groupLangId] || [])
            .filter((relatedDocument) => relatedDocument.id !== doc.id)
            .map((relatedDocument) => i18nWriter(relatedDocument));
        return {
            id: doc.id,
            uid: (_a = doc.data.uid) !== null && _a !== void 0 ? _a : null,
            url: (_b = ctx.LinkResolver.buildUrl({
                linkResolver: linkResolver,
                pageType: doc.type,
                masterLang,
                brokenRoute,
                doc,
            })) !== null && _b !== void 0 ? _b : null,
            type: doc.type,
            href: ctx.urlRewriter.enforceCDN(searchURL),
            tags: doc.tags,
            first_publication_date: doc.first_publication_date ? (0, utils_1.formatDateTime)(doc.first_publication_date) : null,
            last_publication_date: doc.last_publication_date ? (0, utils_1.formatDateTime)(doc.last_publication_date) : null,
            slugs: doc.data.slugs,
            linked_documents: [],
            lang: doc.language,
            alternate_languages: relatedDocs,
            data: widgets,
            ...(withMeta ? doc.metadata : {}),
        };
    };
}
function renderWidgetMocks(ctx) {
    return (mask, content) => {
        if (content.__TYPE__ === slices_1.SlicesContentType && mask.__TYPE__ === models_1.SlicesDefType) {
            return (0, SlicesRenderer_1.default)(ctx).renderMocks(mask, content);
        }
        else if (widgets_1.StaticWidgetContent.is(content) && (0, models_1.isStaticFieldDef)(mask)) {
            return (0, widgets_2.StaticWidgetRenderer)(ctx).renderMocks(mask, content);
        }
        else {
            return renderDefaultWidget(ctx)(mask);
        }
    };
}
function renderMocks(ctx) {
    return (mask, content) => {
        const uid = content.reduce((_acc, [, widget]) => {
            if (widgets_1.UIDContent.is(widget))
                return widget.value;
            return;
        }, undefined);
        const widgets = mask.definitions
            .filter((def) => Object.keys(def).every((v) => v !== "uid"))
            .map((widgetDef) => {
            const filteredWidget = Object.entries(widgetDef).find(([k]) => k !== "config"); // name[0] is the SimpleFieldDef name i.e. the widget name and apiId the api id of the field
            const name = filteredWidget && {
                apiId: filteredWidget[1],
            };
            if (name) {
                const correspondingContent = content.find(([id]) => id === name.apiId);
                const encodedWidgetDef = models_1.WidgetDef.encode(widgetDef);
                const deprecatedArray = name.apiId.match(DEPRECATED_ARRAY_REGEX);
                const isDeprecatedArray = Boolean(deprecatedArray && deprecatedArray[1]);
                const newKey = (isDeprecatedArray ? deprecatedArray[1] : name.apiId);
                if (correspondingContent) {
                    return [newKey, renderWidgetMocks(ctx)(encodedWidgetDef, correspondingContent[1]), isDeprecatedArray];
                }
                else {
                    return [newKey, renderDefaultWidget(ctx)(encodedWidgetDef), isDeprecatedArray];
                }
            }
            throw new Error(""); // todo better error handling
        })
            .reduce((acc, maybeWidget) => {
            if (maybeWidget) {
                const [key, widget, isDeprecatedArray] = maybeWidget;
                if (isDeprecatedArray) {
                    const maybeContent = acc[key];
                    if (maybeContent) {
                        if (Array.isArray(maybeContent)) {
                            return {
                                ...acc,
                                [key]: [...maybeContent, widget],
                            };
                        }
                        else {
                            throw new Error(`[UNEXPECTED ERROR] ${JSON.stringify(maybeContent)} should be an Array`);
                        }
                    }
                    return {
                        ...acc,
                        [key]: [widget],
                    };
                }
                return {
                    ...acc,
                    [key]: widget,
                };
            }
            return acc;
        }, {});
        return {
            id: "mock-doc-id",
            uid,
            url: uid ? `/${uid}` : null,
            type: mask.id,
            href: null,
            tags: [],
            first_publication_date: "1970-01-01T00:00:01+0000",
            last_publication_date: "1970-01-01T00:00:01+0000",
            slugs: [],
            linked_documents: [],
            lang: "en-us",
            alternate_languages: [],
            data: widgets,
        };
    };
}
function renderDefaultWidget(ctx) {
    return (widgetDef) => {
        if (widgetDef.__TYPE__ === models_1.SlicesDefType) {
            return (0, SlicesRenderer_1.default)(ctx).renderDefault(widgetDef);
        }
        else if (widgetDef.__TYPE__ === models_1.SimpleSliceDefType ||
            widgetDef.__TYPE__ === models_1.SharedSliceDefType ||
            widgetDef.__TYPE__ === models_1.CompositeSliceDefType) {
            return (0, widgets_2.SliceWidgetRenderer)(ctx).renderDefault(widgetDef);
        }
        else {
            return (0, widgets_2.StaticWidgetRenderer)(ctx).renderDefault(widgetDef);
        }
    };
}
const DocumentRenderer = (ctx) => {
    return {
        renderV1: renderV1(ctx),
        renderWidgetV1: renderWidgetV1(ctx),
        renderWidgetV2: renderWidgetV2(ctx),
        renderV2: renderV2(ctx),
        renderMocks: renderMocks(ctx),
        renderDefaultWidget: renderDefaultWidget(ctx),
    };
};
exports.default = DocumentRenderer;
