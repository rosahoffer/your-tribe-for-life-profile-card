"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Link_1 = require("@prismicio/types-internal/lib/documents/widgets/nestable/Link");
const Block_1 = require("@prismicio/types-internal/lib/documents/widgets/nestable/StructuredTextContent/Block");
const E = tslib_1.__importStar(require("fp-ts/lib/Either"));
const models_1 = require("../../../models");
const models_2 = require("../../../models");
const utils_1 = require("../../../utils");
const Link_2 = tslib_1.__importDefault(require("../Link"));
function renderStructuredTextLink(link, apiVersion, ctx) {
    const linkType = () => {
        if (Link_1.is.documentLink(link.value))
            return Link_1.LinksTypes.DocumentLink;
        if (Link_1.is.imageLink(link.value))
            return Link_1.LinksTypes.ImageLink;
        if (Link_1.is.fileLink(link.value))
            return Link_1.LinksTypes.FileLink;
        if (Link_1.is.externalLink(link.value))
            return Link_1.LinksTypes.ExternalLink;
        throw new Error(`[UNREACHABLE] unknown Link type for ${JSON.stringify(link)}`);
    };
    if (apiVersion === models_1.ApiVersion.v1) {
        return (0, Link_2.default)(ctx).renderV1(link, undefined);
    }
    else if (apiVersion === models_1.ApiVersion.v2) {
        return (0, Link_2.default)(ctx).renderV2((0, models_2.defaultLinkDef)(linkType()), link, undefined);
    }
    else if (apiVersion === models_1.ApiVersion.mocks) {
        return (0, Link_2.default)(ctx).renderMocks((0, models_2.defaultLinkDef)(linkType()), link);
    }
}
const BlockRenderer = (ctx) => ({
    renderBlock(block) {
        return (apiVersion) => {
            if ((0, Block_1.checkImageBlock)(block)) {
                const linkTo = (() => {
                    if (block.data.linkTo) {
                        const content = {
                            __TYPE__: Link_1.LinksTypes.LinkContent,
                            value: Link_1.Link.encode(block.data.linkTo),
                        };
                        return {
                            linkTo: renderStructuredTextLink(content, apiVersion, ctx),
                        };
                    }
                    return {};
                })();
                const label = block.label ? { label: block.label } : {};
                const direction = block.direction ? { direction: block.direction } : {};
                return {
                    type: "image",
                    url: ctx.urlRewriter.rewriteImageUrl(block.data),
                    alt: (0, utils_1.writeEmptyStringOrNull)(block.data.alt, ctx.emptyStringInsteadOfNull),
                    copyright: (0, utils_1.writeEmptyStringOrNull)(block.data.credits, ctx.emptyStringInsteadOfNull),
                    dimensions: {
                        width: block.data.width,
                        height: block.data.height,
                    },
                    ...linkTo,
                    ...label,
                    ...direction,
                };
            }
            else if ((0, Block_1.checkEmbedBlock)(block)) {
                const label = block.label ? { label: block.label } : {};
                const direction = block.direction ? { direction: block.direction } : {};
                return {
                    type: "embed",
                    oembed: block.data.all,
                    ...label,
                    ...direction,
                };
            }
            else {
                // TextBlock
                const label = block.label ? { label: block.label } : {};
                const direction = block.direction ? { direction: block.direction } : {};
                const spans = (block.content.spans || []).map((m) => {
                    const partial = {
                        start: m.start,
                        end: m.end,
                        type: m.type,
                    };
                    if (m.type === "hyperlink") {
                        const asMaybeLink = Link_1.LinkContent.decode(m.data);
                        const asLink = (() => {
                            if (E.isRight(asMaybeLink)) {
                                const content = {
                                    __TYPE__: Link_1.LinksTypes.LinkContent,
                                    value: Link_1.Link.encode(asMaybeLink.right.value),
                                };
                                return renderStructuredTextLink(content, apiVersion, ctx);
                            }
                            return {};
                        })();
                        return {
                            ...partial,
                            data: asLink,
                        };
                    }
                    else if (m.type === "label") {
                        return {
                            ...partial,
                            data: { label: typeof m.data === "string" ? m.data : "" },
                        };
                    }
                    else {
                        return partial;
                    }
                });
                return {
                    type: block.type,
                    text: block.content.text,
                    ...label,
                    spans,
                    ...direction,
                };
            }
        };
    },
});
exports.default = BlockRenderer;
