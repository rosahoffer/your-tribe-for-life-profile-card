import {
	EmptyContent,
	EmptyContentType,
	StaticWidgetContent,
	UIDContent,
	WidgetContent,
} from "@prismicio/types-internal/lib/documents/widgets"
import { SlicesContentType } from "@prismicio/types-internal/lib/documents/widgets/slices"

import {
	type ApiDocument,
	type ApiModel,
	type LinkResolver,
	type RelatedDocument,
	type RenderContext,
	CompositeSliceDefType,
	Fetch,
	isStaticFieldDef,
	SharedSliceDefType,
	SimpleSliceDefType,
	SlicesDefType,
	WidgetDef,
	WidgetDefO,
} from "./models"
import { formatDateTime } from "./utils"
import { SliceWidgetRenderer, StaticWidgetRenderer } from "./widgets"
import SlicesRenderer from "./widgets/slices/SlicesRenderer"

const DEPRECATED_ARRAY_REGEX = /(\w+)\[\d+]/

function i18nWriter(doc: RelatedDocument): object {
	const result: object = {
		id: doc.id,
		type: doc.typ,
		lang: doc.language,
	}
	if (doc.uid) {
		return {
			...result,
			uid: doc.uid,
		}
	}
	return result
}

function renderWidgetV1(ctx: RenderContext) {
	return (content: WidgetContent, fetchOpt: Fetch.Field | undefined): unknown => {
		if (content.__TYPE__ === EmptyContentType) {
			return undefined
		} else if (StaticWidgetContent.is(content) && !EmptyContent.is(content)) {
			return StaticWidgetRenderer(ctx).renderV1(content, Fetch.extractGroupOrFieldIfAny(fetchOpt))
		} else {
			return SlicesRenderer(ctx).renderV1(content, Fetch.extractSliceFetchIfAny(fetchOpt))
		}
	}
}

function renderWidgetsV1(ctx: RenderContext) {
	return (doc: ApiDocument, content: [string, WidgetContent][], fetch: Fetch.Doc | undefined): unknown => {
		const renderedContent: Record<string, unknown> = {}
		for (const [key, widgetContent] of content) {
			if (key !== "uid") {
				const deprecatedArray = key.match(DEPRECATED_ARRAY_REGEX)
				const isDeprecatedArray = deprecatedArray && deprecatedArray[1]
				// we cast to string since the TS compiler doesn't understand than if `deprecatedArray` exists, the regexp matched so `deprecatedArray[1]` is defined.
				const newKey = (isDeprecatedArray ? deprecatedArray[1] : key) as string
				const maybeContent: undefined | unknown = isDeprecatedArray ? renderedContent[newKey] : undefined

				if (fetch !== undefined) {
					const field = fetch.fields[key]
					if (field !== undefined) {
						if (isDeprecatedArray) {
							renderedContent[newKey] = Array.isArray(maybeContent)
								? [...(maybeContent as unknown[]), renderWidgetV1(ctx)(widgetContent, field)]
								: [renderWidgetV1(ctx)(widgetContent, field)]
						} else {
							renderedContent[newKey] = renderWidgetV1(ctx)(widgetContent, field)
						}
					}
				} else {
					if (isDeprecatedArray) {
						renderedContent[newKey] = Array.isArray(maybeContent)
							? [...(maybeContent as unknown[]), renderWidgetV1(ctx)(widgetContent, undefined)]
							: [renderWidgetV1(ctx)(widgetContent, undefined)]
					} else {
						renderedContent[newKey] = renderWidgetV1(ctx)(widgetContent, undefined)
					}
				}
			}
		}

		return { [doc.type]: renderedContent }
	}
}

function renderV1(ctx: RenderContext) {
	return (
		doc: ApiDocument,
		content: [string, WidgetContent][],
		masterLang: string,
		searchURL: string,
		i18n: { [k: string]: RelatedDocument[] },
		withMeta: boolean,
		brokenRoute?: string,
		linkResolver?: LinkResolver,
		fetchDoc?: Fetch.Doc,
	) => {
		const relatedDocs = (i18n[doc.groupLangId] || [])
			.filter((relatedDocument) => relatedDocument.id !== doc.id)
			.map((relatedDocument) => i18nWriter(relatedDocument))

		const widgets = renderWidgetsV1(ctx)(doc, content, fetchDoc)
		return {
			id: doc.id,
			uid: doc.data.uid ?? null,
			url:
				ctx.LinkResolver.buildUrl({
					linkResolver: linkResolver,
					pageType: doc.type,
					masterLang,
					brokenRoute,
					doc,
				}) ?? null,
			type: doc.type,
			href: ctx.urlRewriter.enforceCDN(searchURL),
			tags: doc.tags,
			first_publication_date: doc.first_publication_date ? formatDateTime(doc.first_publication_date) : null,
			last_publication_date: doc.last_publication_date ? formatDateTime(doc.last_publication_date) : null,
			slugs: doc.data.slugs,
			linked_documents: [],
			lang: doc.language,
			alternate_languages: relatedDocs,
			data: widgets,
			...(withMeta ? doc.metadata : {}),
		}
	}
}

function renderWidgetV2(ctx: RenderContext) {
	return (mask: WidgetDefO, content: WidgetContent, fetchOpt: Fetch.Field | undefined): unknown => {
		if (content.__TYPE__ === SlicesContentType && mask.__TYPE__ === SlicesDefType) {
			return SlicesRenderer(ctx).renderV2(mask, content, Fetch.extractSliceFetchIfAny(fetchOpt))
		} else if (StaticWidgetContent.is(content) && isStaticFieldDef(mask)) {
			return StaticWidgetRenderer(ctx).renderV2(mask, content, Fetch.extractGroupOrFieldIfAny(fetchOpt))
		} else {
			return renderDefaultWidget(ctx)(mask)
		}
	}
}

function renderV2(ctx: RenderContext) {
	return (
		mask: ApiModel,
		doc: ApiDocument,
		masterLang: string,
		content: [string, WidgetContent][],
		searchURL: string,
		i18n: { [k: string]: RelatedDocument[] },
		withMeta: boolean,
		brokenRoute?: string,
		linkResolver?: LinkResolver,
		fetchDoc?: Fetch.Doc,
	) => {
		const widgets = mask.definitions
			.filter((def: WidgetDef) => Object.keys(def).every((v) => v !== "uid"))
			.map<[string, unknown, boolean] | undefined>((widgetDef: WidgetDef) => {
				const filteredWidget = Object.entries(widgetDef).find(([k]) => k !== "config") // name[0] is the SimpleFieldDef name i.e. the widget name and apiId the api id of the field
				const name: { apiId: string } | undefined = filteredWidget && {
					apiId: filteredWidget[1] as string,
				}

				if (name) {
					const correspondingContent = content.find(([id]) => id === name.apiId)
					const encodedWidgetDef = WidgetDef.encode(widgetDef)
					const fetchField = fetchDoc?.fields[name.apiId]

					const deprecatedArray = name.apiId.match(DEPRECATED_ARRAY_REGEX)
					const isDeprecatedArray = Boolean(deprecatedArray && deprecatedArray[1])
					const newKey = (isDeprecatedArray ? (deprecatedArray as RegExpExecArray)[1] : name.apiId) as string

					if (correspondingContent) {
						if (fetchDoc === undefined || fetchField !== undefined) {
							return [
								newKey,
								renderWidgetV2(ctx)(encodedWidgetDef, correspondingContent[1], fetchField),
								isDeprecatedArray,
							]
						} else {
							return undefined
						}
					} else {
						//TODO: not sure about that
						if (fetchDoc === undefined || fetchField !== undefined) {
							return [newKey, renderDefaultWidget(ctx)(encodedWidgetDef), isDeprecatedArray]
						} else {
							return undefined
						}
					}
				}
				throw new Error("") // todo better error handling
			})
			.reduce<{ [_: string]: unknown }>((acc, maybeWidget) => {
				if (maybeWidget) {
					const [key, widget, isDeprecatedArray] = maybeWidget
					if (isDeprecatedArray) {
						const maybeContent: unknown = acc[key]
						if (maybeContent) {
							if (Array.isArray(maybeContent)) {
								return {
									...acc,
									[key]: [...(maybeContent as unknown[]), widget],
								}
							} else {
								throw new Error(`[UNEXPECTED ERROR] ${JSON.stringify(maybeContent)} should be an Array`)
							}
						}
						return {
							...acc,
							[key]: [widget],
						}
					}
					return {
						...acc,
						[key]: widget,
					}
				}
				return acc
			}, {})

		const relatedDocs = (i18n[doc.groupLangId] || [])
			.filter((relatedDocument) => relatedDocument.id !== doc.id)
			.map((relatedDocument) => i18nWriter(relatedDocument))

		return {
			id: doc.id,
			uid: doc.data.uid ?? null,
			url:
				ctx.LinkResolver.buildUrl({
					linkResolver: linkResolver,
					pageType: doc.type,
					masterLang,
					brokenRoute,
					doc,
				}) ?? null,
			type: doc.type,
			href: ctx.urlRewriter.enforceCDN(searchURL),
			tags: doc.tags,
			first_publication_date: doc.first_publication_date ? formatDateTime(doc.first_publication_date) : null,
			last_publication_date: doc.last_publication_date ? formatDateTime(doc.last_publication_date) : null,
			slugs: doc.data.slugs,
			linked_documents: [],
			lang: doc.language,
			alternate_languages: relatedDocs,
			data: widgets,
			...(withMeta ? doc.metadata : {}),
		}
	}
}

function renderWidgetMocks(ctx: RenderContext) {
	return (mask: WidgetDefO, content: WidgetContent): unknown => {
		if (content.__TYPE__ === SlicesContentType && mask.__TYPE__ === SlicesDefType) {
			return SlicesRenderer(ctx).renderMocks(mask, content)
		} else if (StaticWidgetContent.is(content) && isStaticFieldDef(mask)) {
			return StaticWidgetRenderer(ctx).renderMocks(mask, content)
		} else {
			return renderDefaultWidget(ctx)(mask)
		}
	}
}

function renderMocks(ctx: RenderContext) {
	return (mask: ApiModel, content: [string, WidgetContent][]) => {
		const uid = content.reduce<string | undefined>((_acc, [, widget]) => {
			if (UIDContent.is(widget)) return widget.value
			return
		}, undefined)

		const widgets = mask.definitions
			.filter((def: WidgetDef) => Object.keys(def).every((v) => v !== "uid"))
			.map<[string, unknown, boolean]>((widgetDef: WidgetDef) => {
				const filteredWidget = Object.entries(widgetDef).find(([k]) => k !== "config") // name[0] is the SimpleFieldDef name i.e. the widget name and apiId the api id of the field
				const name: { apiId: string } | undefined = filteredWidget && {
					apiId: filteredWidget[1] as string,
				}

				if (name) {
					const correspondingContent = content.find(([id]) => id === name.apiId)
					const encodedWidgetDef = WidgetDef.encode(widgetDef)

					const deprecatedArray = name.apiId.match(DEPRECATED_ARRAY_REGEX)
					const isDeprecatedArray = Boolean(deprecatedArray && deprecatedArray[1])
					const newKey = (isDeprecatedArray ? (deprecatedArray as RegExpExecArray)[1] : name.apiId) as string

					if (correspondingContent) {
						return [newKey, renderWidgetMocks(ctx)(encodedWidgetDef, correspondingContent[1]), isDeprecatedArray]
					} else {
						return [newKey, renderDefaultWidget(ctx)(encodedWidgetDef), isDeprecatedArray]
					}
				}
				throw new Error("") // todo better error handling
			})
			.reduce<{ [_: string]: unknown }>((acc, maybeWidget) => {
				if (maybeWidget) {
					const [key, widget, isDeprecatedArray] = maybeWidget
					if (isDeprecatedArray) {
						const maybeContent: unknown = acc[key]
						if (maybeContent) {
							if (Array.isArray(maybeContent)) {
								return {
									...acc,
									[key]: [...(maybeContent as unknown[]), widget],
								}
							} else {
								throw new Error(`[UNEXPECTED ERROR] ${JSON.stringify(maybeContent)} should be an Array`)
							}
						}
						return {
							...acc,
							[key]: [widget],
						}
					}
					return {
						...acc,
						[key]: widget,
					}
				}
				return acc
			}, {})

		return {
			id: "mock-doc-id",
			uid,
			url: uid ? `/${uid}` : null,
			type: mask.id,
			href: null,
			tags: [],
			first_publication_date: "1970-01-01T00:00:01+0000",
			last_publication_date: "1970-01-01T00:00:01+0000",
			slugs: [],
			linked_documents: [],
			lang: "en-us",
			alternate_languages: [],
			data: widgets,
		}
	}
}

function renderDefaultWidget(ctx: RenderContext) {
	return (widgetDef: WidgetDefO) => {
		if (widgetDef.__TYPE__ === SlicesDefType) {
			return SlicesRenderer(ctx).renderDefault(widgetDef)
		} else if (
			widgetDef.__TYPE__ === SimpleSliceDefType ||
			widgetDef.__TYPE__ === SharedSliceDefType ||
			widgetDef.__TYPE__ === CompositeSliceDefType
		) {
			return SliceWidgetRenderer(ctx).renderDefault(widgetDef)
		} else {
			return StaticWidgetRenderer(ctx).renderDefault(widgetDef)
		}
	}
}

const DocumentRenderer = (ctx: RenderContext) => {
	return {
		renderV1: renderV1(ctx),
		renderWidgetV1: renderWidgetV1(ctx),
		renderWidgetV2: renderWidgetV2(ctx),
		renderV2: renderV2(ctx),
		renderMocks: renderMocks(ctx),
		renderDefaultWidget: renderDefaultWidget(ctx),
	}
}
export default DocumentRenderer
