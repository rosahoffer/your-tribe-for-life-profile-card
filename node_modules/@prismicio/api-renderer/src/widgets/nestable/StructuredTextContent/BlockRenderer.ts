import { is, Link, LinkContent, LinksTypes } from "@prismicio/types-internal/lib/documents/widgets/nestable/Link"
import {
	type Block,
	checkEmbedBlock,
	checkImageBlock,
} from "@prismicio/types-internal/lib/documents/widgets/nestable/StructuredTextContent/Block"
import * as E from "fp-ts/lib/Either"

import { type RenderContext, ApiVersion } from "../../../models"
import { defaultLinkDef } from "../../../models"
import { writeEmptyStringOrNull } from "../../../utils"
import LinkRenderer from "../Link"

function renderStructuredTextLink(link: LinkContent, apiVersion: ApiVersion, ctx: RenderContext) {
	const linkType = () => {
		if (is.documentLink(link.value)) return LinksTypes.DocumentLink
		if (is.imageLink(link.value)) return LinksTypes.ImageLink
		if (is.fileLink(link.value)) return LinksTypes.FileLink
		if (is.externalLink(link.value)) return LinksTypes.ExternalLink
		throw new Error(`[UNREACHABLE] unknown Link type for ${JSON.stringify(link)}`)
	}

	if (apiVersion === ApiVersion.v1) {
		return LinkRenderer(ctx).renderV1(link, undefined)
	} else if (apiVersion === ApiVersion.v2) {
		return LinkRenderer(ctx).renderV2(defaultLinkDef(linkType()), link, undefined)
	} else if (apiVersion === ApiVersion.mocks) {
		return LinkRenderer(ctx).renderMocks(defaultLinkDef(linkType()), link)
	}
}

const BlockRenderer = (ctx: RenderContext) => ({
	renderBlock(block: Block): (apiVersion: ApiVersion) => unknown {
		return (apiVersion: ApiVersion) => {
			if (checkImageBlock(block)) {
				const linkTo = (() => {
					if (block.data.linkTo) {
						const content = {
							__TYPE__: LinksTypes.LinkContent,
							value: Link.encode(block.data.linkTo),
						} as LinkContent
						return {
							linkTo: renderStructuredTextLink(content, apiVersion, ctx),
						}
					}
					return {}
				})()

				const label = block.label ? { label: block.label } : {}

				const direction = block.direction ? { direction: block.direction } : {}

				return {
					type: "image",
					url: ctx.urlRewriter.rewriteImageUrl(block.data),
					alt: writeEmptyStringOrNull(block.data.alt, ctx.emptyStringInsteadOfNull),
					copyright: writeEmptyStringOrNull(block.data.credits, ctx.emptyStringInsteadOfNull),
					dimensions: {
						width: block.data.width,
						height: block.data.height,
					},
					...linkTo,
					...label,
					...direction,
				}
			} else if (checkEmbedBlock(block)) {
				const label = block.label ? { label: block.label } : {}
				const direction = block.direction ? { direction: block.direction } : {}

				return {
					type: "embed",
					oembed: block.data.all,
					...label,
					...direction,
				}
			} else {
				// TextBlock
				const label = block.label ? { label: block.label } : {}
				const direction = block.direction ? { direction: block.direction } : {}
				const spans = (block.content.spans || []).map((m) => {
					const partial = {
						start: m.start,
						end: m.end,
						type: m.type,
					}
					if (m.type === "hyperlink") {
						const asMaybeLink = LinkContent.decode(m.data)
						const asLink = (() => {
							if (E.isRight(asMaybeLink)) {
								const content = {
									__TYPE__: LinksTypes.LinkContent,
									value: Link.encode(asMaybeLink.right.value),
								} as LinkContent
								return renderStructuredTextLink(content, apiVersion, ctx)
							}
							return {}
						})()

						return {
							...partial,
							data: asLink,
						}
					} else if (m.type === "label") {
						return {
							...partial,
							data: { label: typeof m.data === "string" ? m.data : "" },
						}
					} else {
						return partial
					}
				})
				return {
					type: block.type,
					text: block.content.text,
					...label,
					spans,
					...direction,
				}
			}
		}
	},
})

export default BlockRenderer
