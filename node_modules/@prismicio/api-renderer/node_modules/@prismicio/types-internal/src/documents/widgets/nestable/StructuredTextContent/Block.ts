import * as E from "fp-ts/lib/Either"
import * as t from "io-ts"

import {
	RichTextNodeType,
	RichTextNodeTypeCodec,
} from "../../../../customtypes/widgets/nestable"
import { StringOrNull } from "../../../../validators"
import { nullable, refineType } from "../../../../validators/function"
import { EmbedContent } from "../EmbedContent"
import { ImageContentView } from "../ImageContent"
import { Link } from "../Link"

export const Meta = t.exact(
	t.intersection([
		t.partial({
			data: t.unknown,
		}),
		t.type({
			start: t.number,
			end: t.number,
			type: t.union([RichTextNodeTypeCodec, t.literal("label")]),
		}),
	]),
)
export type Meta = t.TypeOf<typeof Meta>

// export alias for code clarity
export const Span = Meta
export type Span = Meta

export const ValidatedMetas = new t.Type<Meta[], Meta[], unknown>(
	"ValidatedMetas",
	(metas): metas is Meta[] => Array.isArray(metas) && metas.every(Meta.is),
	(metas: unknown, c) => {
		if (Array.isArray(metas)) {
			const res = metas
				.reduce<Array<Meta>>((acc, maybeMeta) => {
					const maybeDecodedMeta = Meta.decode(maybeMeta)
					if (E.isRight(maybeDecodedMeta)) {
						const meta = maybeDecodedMeta.right
						// if it's an hyperlink it should have data validated as link otherwise we don't care and keep the meta
						if (
							(meta.data &&
								meta.type === "hyperlink" &&
								E.isRight(Link.validate(meta.data, c))) ||
							meta.type !== "hyperlink"
						) {
							return [...acc, meta]
						}
					}
					return acc
				}, [])
				.sort((m1: Meta, m2: Meta) => m1.start - m2.start)
			return t.success(res)
		} else return t.failure(metas, c)
	},
	(m) => t.array(Meta).encode(m),
)

export const ImageBlock = t.exact(
	t.intersection([
		t.type({
			type: t.literal(RichTextNodeType.image),
			data: t.intersection([
				ImageContentView,
				t.partial({
					linkTo: nullable(Link),
				}),
			]),
		}),
		t.partial({
			label: StringOrNull,
			direction: StringOrNull,
		}),
	]),
)
export type ImageBlock = t.TypeOf<typeof ImageBlock>
export function checkImageBlock(block: Block): block is ImageBlock {
	return block.type === RichTextNodeType.image
}

export const EmbedBlock = t.exact(
	t.intersection([
		t.type({
			type: t.literal(RichTextNodeType.embed),
			data: EmbedContent,
		}),
		t.partial({
			label: StringOrNull,
			direction: StringOrNull,
		}),
	]),
)
export type EmbedBlock = t.TypeOf<typeof EmbedBlock>
export function checkEmbedBlock(block: Block): block is EmbedBlock {
	return block.type === RichTextNodeType.embed
}

export const TextBlock = t.exact(
	t.intersection([
		t.type({
			type: refineType(
				RichTextNodeTypeCodec,
				`string which isn't ${RichTextNodeType.image} ${RichTextNodeType.embed}`,
				(s) => s !== RichTextNodeType.image && s !== RichTextNodeType.embed,
			),
			content: t.intersection([
				t.type({
					text: t.string,
				}),
				t.partial({
					spans: ValidatedMetas,
				}),
			]),
		}),
		t.partial({
			label: t.string,
			direction: t.string,
		}),
	]),
)
export type TextBlock = t.TypeOf<typeof TextBlock>

export const Block = t.union([ImageBlock, EmbedBlock, TextBlock])
export type Block = t.TypeOf<typeof Block>
