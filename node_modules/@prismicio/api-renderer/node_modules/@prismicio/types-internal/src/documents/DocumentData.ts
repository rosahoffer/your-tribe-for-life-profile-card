import { isRight } from "fp-ts/lib/Either"
import * as O from "fp-ts/lib/Option"
import * as t from "io-ts"

import { type WidgetContent, type WidgetKey, Widget } from "./widgets"

type DocumentData = Map<WidgetKey, O.Option<WidgetContent>>
function computeWidget(
	key: WidgetKey,
	widgets: Map<WidgetKey, unknown>,
	widgetTypes: Map<WidgetKey, string>,
	widgetPositions: Map<WidgetKey, number>,
): O.Option<WidgetContent> {
	const widget = widgets.get(key)
	if (widget === undefined) {
		return O.none
	}
	return Widget.fromJson(key, widget, widgetTypes, widgetPositions)
}

const DocumentData = {
	getWidget(
		key: WidgetKey,
		widgets: Map<WidgetKey, unknown>,
		widgetTypes: Map<WidgetKey, string>,
		widgetPositions: Map<WidgetKey, number>,
		parsed: Map<string, O.Option<WidgetContent>>,
	): O.Option<WidgetContent> {
		const widget = parsed.get(key)
		if (widget === undefined) {
			return computeWidget(key, widgets, widgetTypes, widgetPositions)
		}
		return widget
	},

	fromJson(
		widgets: Map<WidgetKey, unknown>,
		widgetTypes: Map<WidgetKey, string>,
		widgetPositions: Map<WidgetKey, number>,
	): DocumentData {
		return Array.from(widgets.keys()).reduce<
			Map<WidgetKey, O.Option<WidgetContent>>
		>((acc, widgetKey) => {
			const parsedWidget = this.getWidget(
				widgetKey,
				widgets,
				widgetTypes,
				widgetPositions,
				acc,
			)
			return new Map([...Array.from(acc.entries()), [widgetKey, parsedWidget]])
		}, new Map<WidgetKey, O.Option<WidgetContent>>())
	},

	partitionData(data: { [p: string]: unknown }): {
		types: Map<string, string>
		positions: Map<string, number>
		widgets: Map<WidgetKey, unknown>
		slugs: ReadonlyArray<string>
		uid: string | undefined
	} {
		const fields: [string, unknown][] = Object.entries(data)

		const { types, positions, widgets } = fields.reduce(
			(acc, [k, v]) => {
				if (k.endsWith("_TYPE")) {
					const decodedValue = t.string.decode(v)
					if (isRight(decodedValue)) {
						return {
							...acc,
							types: acc.types.set(
								k.substring(0, k.length - 5),
								decodedValue.right,
							),
						}
					}
				}
				if (k.endsWith("_POSITION") && typeof v === "number") {
					return {
						...acc,
						positions: acc.positions.set(k.substring(0, k.length - 9), v),
					}
				}
				if (!k.endsWith("_POSITION") && !k.endsWith("_TYPE")) {
					return {
						...acc,
						widgets: acc.widgets.set(k, v),
					}
				}
				return acc
			},
			{
				types: new Map<string, string>(),
				positions: new Map<string, number>(),
				widgets: new Map<string, unknown>(),
			},
		)

		const slugs = (data["slugs_INTERNAL"] as string[]) || []
		const uid = data["uid"] as string | undefined

		return {
			widgets,
			types,
			positions,
			uid,
			slugs,
		}
	},
}

export default DocumentData
