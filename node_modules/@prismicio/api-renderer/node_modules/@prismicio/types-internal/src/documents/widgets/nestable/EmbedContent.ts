import { either } from "fp-ts"
import { pipe } from "fp-ts/function"
import * as t from "io-ts"

import { NumberOrNull, StringOrNull } from "../../../validators"
import { addType } from "../../../validators/function"

export const EmbedContentType = "EmbedContent"

export type EmbedContent = t.TypeOf<typeof EmbedContentC> & {
	all: unknown
}

export type EmbedContentO = t.OutputOf<typeof EmbedContentC> & {
	all: unknown
}

export const EmbedContent = new t.Type<EmbedContentO, unknown, unknown>(
	"EmbedContent",
	(u): u is EmbedContentO => (u as EmbedContentO).__TYPE__ === EmbedContentType,
	(u) => {
		return pipe(
			EmbedContentC.decode(u),
			either.map((s) => ({
				...EmbedContentC.encode(s),
				all: u,
			})),
		)
	},
	(ec: EmbedContentO) => EmbedContentC.encode(ec),
)

export const EmbedContentC = addType(
	t.exact(
		t.intersection([
			t.type({
				embed_url: t.string,
				type: t.string,
			}),
			t.partial({
				version: t.union([t.string, t.number, t.null]),
				title: StringOrNull,
				author_name: StringOrNull,
				author_url: StringOrNull,
				provider_name: StringOrNull,
				provider_url: StringOrNull,
				cache_age: t.union([t.string, t.number, t.null]),
				thumbnail_url: StringOrNull,
				thumbnail_width: NumberOrNull,
				thumbnail_height: NumberOrNull,
				html: StringOrNull,
			}),
		]),
	),
	EmbedContentType,
)
