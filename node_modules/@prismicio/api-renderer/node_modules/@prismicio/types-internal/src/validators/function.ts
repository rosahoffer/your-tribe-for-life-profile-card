import { either } from "fp-ts"
import { pipe } from "fp-ts/function"
import * as t from "io-ts"
import { mapOutput } from "io-ts-types/mapOutput"

export function nullable<A, O>(c: t.Type<A, O>) {
	return t.union([c, t.null, t.undefined])
}

export function refineType<A, O, I>(
	type: t.Type<A, O, I>,
	newName: string,
	pred: (a: A) => boolean,
): t.Type<A, O, I> {
	return new t.Type<A, O, I>(
		newName,
		type.is,
		(u, c) =>
			pipe(
				type.validate(u, c),
				either.chain((v) => (pred(v) ? t.success(v) : t.failure(u, c))),
			),
		type.encode,
	)
}

export function filterDouble(value: string): number | null {
	if (value === "") {
		return null
	}
	const result = Number(value)
	return Number.isNaN(result) ? null : result
}

export function formatDateTime(date: Date): string {
	return date.toISOString().replace(/\.\d{3}Z$/, "+0000")
}

export function formatDate(date: Date): string {
	return date.toISOString().replace(/T.*/, "")
}

export function grouped<A>(array: A[], n: number): A[][] {
	return array.reduce((acc, curr, idx) => {
		if (idx % n === 0) {
			acc.push([curr])
		} else {
			/* eslint-disable  @typescript-eslint/no-non-null-assertion */
			acc[Math.floor(idx / n)]!.push(curr)
		}
		return acc
	}, new Array<A[]>())
}

export function objectToMap<T>(object: { [key: string]: T }): Map<string, T> {
	return new Map(Object.entries(object))
}

export function isEmpty(obj: object) {
	for (const _x in obj) {
		return false
	}
	return true
}

export function addType<A, O extends object, I, T extends string>(
	codec: t.Type<A, O, I>,
	t: T,
): t.Type<A, O & { __TYPE__: T }, I> {
	return mapOutput(codec, (o) => ({ ...o, __TYPE__: t } as const))
}
