import * as t from "io-ts"

import { WidgetKey } from "../../../documents/widgets"
import { StringOrNull } from "../../../validators"
import { WidgetTypes } from "../WidgetTypes"
import CompositeSlice from "./CompositeSlice"
import LegacySlice from "./LegacySlice"
import { SharedSlice } from "./SharedSlice"
import SharedSliceRef from "./SharedSliceRef"
import { SlicesTypes } from "./SlicesTypes"

export const SlicesLabels = t.union([
	t.record(
		t.string,
		t.readonlyArray(
			t.exact(
				t.intersection([
					t.type({
						name: t.string,
					}),
					t.partial({
						display: t.string,
					}),
				]),
			),
		),
	),
	t.null,
])
export type SlicesLabels = t.TypeOf<typeof SlicesLabels>

export function slicesConfigReader<T extends SharedSlice | SharedSliceRef>(
	codec: t.Type<T, unknown>,
) {
	return t.exact(
		t.partial({
			label: StringOrNull,
			labels: SlicesLabels,
			choices: t.record(
				WidgetKey,
				t.union([LegacySlice, CompositeSlice, codec]),
			),
		}),
	)
}
export const StaticSlicesConfig = slicesConfigReader(SharedSlice)
export type StaticSlicesConfig = t.TypeOf<typeof StaticSlicesConfig>

export const DynamicSlicesConfig = slicesConfigReader(SharedSliceRef)
export type DynamicSlicesConfig = t.TypeOf<typeof DynamicSlicesConfig>

const SlicesConfig = {
	toStatic(
		config: DynamicSlicesConfig,
		sharedSlices: Map<string, SharedSlice>,
	): StaticSlicesConfig {
		const choices: {
			[key: string]: LegacySlice | CompositeSlice | SharedSlice
		} = Object.entries(config.choices || {}).reduce((acc, [ref, slice]) => {
			if (slice.type === SlicesTypes.SharedSlice) {
				const sharedSlice = sharedSlices.get(ref)
				if (sharedSlice) return { ...acc, [ref]: sharedSlice }
				else return acc
			} else {
				return { ...acc, [ref]: slice }
			}
		}, {})

		return { ...config, choices } as StaticSlicesConfig
	},
}

export function slicesReader<
	T extends StaticSlicesConfig | DynamicSlicesConfig,
>(codec: t.Type<T, unknown>) {
	return t.exact(
		t.intersection([
			t.type({
				type: t.union([
					t.literal(WidgetTypes.Slices),
					t.literal(WidgetTypes.LegacySlices),
				]),
			}),
			t.partial({
				fieldset: StringOrNull,
				config: codec,
			}),
		]),
	)
}

export const StaticSlices = slicesReader(StaticSlicesConfig)
export type StaticSlices = t.TypeOf<typeof StaticSlices>

export const DynamicSlices = slicesReader(DynamicSlicesConfig)
export type DynamicSlices = t.TypeOf<typeof DynamicSlices>

export const Slices = {
	toStatic(
		slices: DynamicSlices,
		sharedSlices: Map<string, SharedSlice>,
	): StaticSlices {
		if (!slices.config) return slices as StaticSlices
		else {
			return {
				...slices,
				config: SlicesConfig.toStatic(slices.config, sharedSlices),
			}
		}
	},
}
