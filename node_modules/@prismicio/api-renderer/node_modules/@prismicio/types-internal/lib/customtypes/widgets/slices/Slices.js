"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Slices = exports.DynamicSlices = exports.StaticSlices = exports.slicesReader = exports.DynamicSlicesConfig = exports.StaticSlicesConfig = exports.slicesConfigReader = exports.SlicesLabels = void 0;
const tslib_1 = require("tslib");
const t = (0, tslib_1.__importStar)(require("io-ts"));
const widgets_1 = require("../../../documents/widgets");
const validators_1 = require("../../../validators");
const WidgetTypes_1 = require("../WidgetTypes");
const CompositeSlice_1 = (0, tslib_1.__importDefault)(require("./CompositeSlice"));
const LegacySlice_1 = (0, tslib_1.__importDefault)(require("./LegacySlice"));
const SharedSlice_1 = require("./SharedSlice");
const SharedSliceRef_1 = (0, tslib_1.__importDefault)(require("./SharedSliceRef"));
const SlicesTypes_1 = require("./SlicesTypes");
exports.SlicesLabels = t.union([
    t.record(t.string, t.readonlyArray(t.exact(t.intersection([
        t.type({
            name: t.string,
        }),
        t.partial({
            display: t.string,
        }),
    ])))),
    t.null,
]);
function slicesConfigReader(codec) {
    return t.exact(t.partial({
        label: validators_1.StringOrNull,
        labels: exports.SlicesLabels,
        choices: t.record(widgets_1.WidgetKey, t.union([LegacySlice_1.default, CompositeSlice_1.default, codec])),
    }));
}
exports.slicesConfigReader = slicesConfigReader;
exports.StaticSlicesConfig = slicesConfigReader(SharedSlice_1.SharedSlice);
exports.DynamicSlicesConfig = slicesConfigReader(SharedSliceRef_1.default);
const SlicesConfig = {
    toStatic(config, sharedSlices) {
        const choices = Object.entries(config.choices || {}).reduce((acc, [ref, slice]) => {
            if (slice.type === SlicesTypes_1.SlicesTypes.SharedSlice) {
                const sharedSlice = sharedSlices.get(ref);
                if (sharedSlice)
                    return { ...acc, [ref]: sharedSlice };
                else
                    return acc;
            }
            else {
                return { ...acc, [ref]: slice };
            }
        }, {});
        return { ...config, choices };
    },
};
function slicesReader(codec) {
    return t.exact(t.intersection([
        t.type({
            type: t.union([
                t.literal(WidgetTypes_1.WidgetTypes.Slices),
                t.literal(WidgetTypes_1.WidgetTypes.LegacySlices),
            ]),
        }),
        t.partial({
            fieldset: validators_1.StringOrNull,
            config: codec,
        }),
    ]));
}
exports.slicesReader = slicesReader;
exports.StaticSlices = slicesReader(exports.StaticSlicesConfig);
exports.DynamicSlices = slicesReader(exports.DynamicSlicesConfig);
exports.Slices = {
    toStatic(slices, sharedSlices) {
        if (!slices.config)
            return slices;
        else {
            return {
                ...slices,
                config: SlicesConfig.toStatic(slices.config, sharedSlices),
            };
        }
    },
};
