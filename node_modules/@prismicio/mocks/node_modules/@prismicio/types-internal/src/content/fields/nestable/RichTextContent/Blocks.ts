import { either } from "fp-ts"
import { isLeft, isRight } from "fp-ts/lib/Either"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import {
	RichTextNodeType,
	RichTextNodeTypeCodec,
} from "../../../../customtypes/widgets/nestable"
import { StringOrNull } from "../../../../validators"
import { nullable, refineType } from "../../../../validators/function"
import {
	EmbedContent,
	EmbedContentLegacy,
	EmbedContentType,
	EmbedLegacy,
} from "../EmbedContent"
import { ImageContentView } from "../ImageContent"
import { Link, LinkLegacy } from "../LinkContent"

export const Meta = t.exact(
	t.intersection([
		t.partial({
			data: t.unknown,
		}),
		t.type({
			start: t.number,
			end: t.number,
			type: t.union([RichTextNodeTypeCodec, t.literal("label")]),
		}),
	]),
)
export type Meta = t.TypeOf<typeof Meta>

// export alias for code clarity
export const Span = Meta
export type Span = Meta

export const ValidatedMetas = (linkCodec: LinkCodec) =>
	new t.Type<Meta[], Meta[], unknown>(
		"ValidatedMetas",
		(metas): metas is Meta[] => Array.isArray(metas) && metas.every(Meta.is),
		(metas: unknown, c) => {
			if (Array.isArray(metas)) {
				const res = metas
					.reduce<Array<Meta>>((acc, maybeMeta) => {
						const maybeDecodedMeta = Meta.decode(maybeMeta)
						if (isRight(maybeDecodedMeta)) {
							const meta = maybeDecodedMeta.right
							// if it's an hyperlink it should have data validated as link otherwise we don't care and keep the meta
							if (meta.data && meta.type === "hyperlink") {
								const decoded = linkCodec.decode(meta.data)
								if (isLeft(decoded)) return acc

								return [...acc, { ...meta, data: decoded.right }]
							} else if (meta.type !== "hyperlink") {
								return [...acc, meta]
							}
						}
						return acc
					}, [])
					.sort((m1: Meta, m2: Meta) => m1.start - m2.start)
				return t.success(res)
			} else return t.failure(metas, c)
		},
		(m) => {
			return m.reduce<Array<Meta>>((acc, meta) => {
				if (meta.type === "hyperlink" && meta.data) {
					// since the Span data are typed as unknown we have to redecode for type safety and then encode to either new format or legacy.
					const decoded = linkCodec.decode(meta.data)
					if (isLeft(decoded)) return acc

					return [...acc, { ...meta, data: linkCodec.encode(decoded.right) }]
				}
				return [...acc, Meta.encode(meta)]
			}, [])
		},
	)

export const ImageBlock = t.exact(
	t.intersection([
		t.type({
			type: t.literal(RichTextNodeType.image),
			data: t.intersection([
				ImageContentView,
				t.partial({
					linkTo: nullable(Link),
				}),
			]),
		}),
		t.partial({
			label: StringOrNull,
			direction: StringOrNull,
		}),
	]),
)
export type ImageBlock = t.TypeOf<typeof ImageBlock>
export function checkImageBlock(block: Block): block is ImageBlock {
	return block.type === RichTextNodeType.image
}

const embedBlockLegacyCodec = t.exact(
	t.intersection([
		t.type({
			type: t.literal(RichTextNodeType.embed),
			data: t.unknown,
		}),
		t.partial({
			label: StringOrNull,
			direction: StringOrNull,
		}),
	]),
)

type EmbedBlockLegacy = t.TypeOf<typeof embedBlockLegacyCodec>

const EmbedBlockLegacy = new t.Type<EmbedBlock, EmbedBlockLegacy, unknown>(
	"EmbedBlockLegacy",
	(u): u is EmbedBlock => (u as EmbedBlock).type === "embed",
	(block) =>
		pipe(
			embedBlockLegacyCodec.decode(block),
			either.chain((decodedBlock) => {
				return either.map<EmbedLegacy, [EmbedBlockLegacy, EmbedLegacy]>(
					(decodedData: EmbedLegacy) => {
						return [decodedBlock, decodedData]
					},
				)(EmbedContentLegacy.decode(decodedBlock.data))
			}),
			either.map(([block, parsedData]) => {
				return EmbedBlock.encode({
					...block,
					data: {
						...parsedData,
						__TYPE__: EmbedContentType,
						all: block.data,
					},
				})
			}),
		),
	(embedBlock: EmbedBlock): EmbedBlockLegacy => {
		return {
			...embedBlockLegacyCodec.encode(embedBlock),
			data: EmbedContentLegacy.encode(embedBlock.data),
		}
	},
)
export const EmbedBlock = t.exact(
	t.intersection([
		t.type({
			type: t.literal(RichTextNodeType.embed),
			data: EmbedContent,
		}),
		t.partial({
			label: StringOrNull,
			direction: StringOrNull,
		}),
	]),
)
export type EmbedBlock = t.TypeOf<typeof EmbedBlock>
export function checkEmbedBlock(block: Block): block is EmbedBlock {
	return block.type === RichTextNodeType.embed
}

type LinkCodec = typeof Link | typeof LinkLegacy
const TextBlockCodec = (linkCodec: LinkCodec) =>
	t.exact(
		t.intersection([
			t.type({
				type: refineType(
					RichTextNodeTypeCodec,
					`string which isn't ${RichTextNodeType.image} ${RichTextNodeType.embed}`,
					(s) => s !== RichTextNodeType.image && s !== RichTextNodeType.embed,
				),
				content: t.intersection([
					t.type({
						text: t.string,
					}),
					t.partial({
						spans: ValidatedMetas(linkCodec),
					}),
				]),
			}),
			t.partial({
				label: t.string,
				direction: t.string,
			}),
		]),
	)

export const TextBlock = TextBlockCodec(Link)
export type TextBlock = t.TypeOf<typeof TextBlock>

const TextBlockLegacy = TextBlockCodec(LinkLegacy)
type TextBlockLegacy = t.TypeOf<typeof TextBlockLegacy>

const legacyBlockCodec = t.union([
	EmbedBlockLegacy,
	ImageBlock,
	TextBlockLegacy,
])
type BlockLegacy = t.TypeOf<typeof legacyBlockCodec>

export const BlockLegacy = new t.Type<Block, BlockLegacy, unknown>(
	"BlockLegacy",
	(u): u is Block =>
		EmbedBlockLegacy.is(u) || ImageBlock.is(u) || TextBlockLegacy.is(u),
	(legacyBlock) => legacyBlockCodec.decode(legacyBlock),
	(block: Block) => {
		if (ImageBlock.is(block)) return ImageBlock.encode(block)
		else if (EmbedBlock.is(block))
			return EmbedBlockLegacy.encode(block) as BlockLegacy
		else return TextBlockLegacy.encode(block)
	},
)
export const Block = t.union([ImageBlock, EmbedBlock, TextBlock])
export type Block = t.TypeOf<typeof Block>
