import { either } from "fp-ts"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import type {
	FieldOrSliceType,
	LegacyContentCtx,
	WithTypes,
} from "../../LegacyContentCtx"
import { hasContentType } from "../../utils"
import { SliceItemContent, SlicesItemLegacy } from "./SliceItem"

export const SlicesContentType = "SliceContentType"

export const isSlicesContent = (u: unknown): u is SlicesContent =>
	hasContentType(u) && u.__TYPE__ === SlicesContentType

type SlicesLegacy = Array<unknown>

export const SlicesLegacy = (ctx: LegacyContentCtx) => {
	const codec = t.array(SlicesItemLegacy(ctx))

	return new t.Type<SlicesContent, WithTypes<SlicesLegacy>, unknown>(
		"SlicesLegacy",
		isSlicesContent,
		(items) => {
			return pipe(
				codec.decode(items),
				either.map((parsedSlices) => {
					return {
						__TYPE__: SlicesContentType,
						value: parsedSlices,
					}
				}),
			)
		},
		(s: SlicesContent) => {
			const result = codec.encode(s.value)

			return {
				content: result.map((s) => s.content),
				types: result.reduce<Record<string, FieldOrSliceType>>(
					(acc, s) => ({ ...acc, ...s.types }),
					{ [ctx.keyOfType]: "Slices" },
				),
			}
		},
	)
}

export const SlicesContent = t.type({
	__TYPE__: t.literal(SlicesContentType),
	value: t.array(SliceItemContent),
})

export type SlicesContent = t.TypeOf<typeof SlicesContent>
