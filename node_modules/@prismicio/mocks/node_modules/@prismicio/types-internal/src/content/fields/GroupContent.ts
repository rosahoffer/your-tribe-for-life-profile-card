import { either } from "fp-ts"
import { isLeft } from "fp-ts/lib/Either"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import {
	FieldOrSliceType,
	getFieldCtx,
	LegacyContentCtx,
	WithTypes,
} from "../LegacyContentCtx"
import { hasContentType } from "../utils"
import { NestableContent, NestableLegacy } from "./nestable"

export const GroupItemContentType = "GroupItemContent" as const

export const GroupItemContent = t.strict({
	__TYPE__: t.literal(GroupItemContentType),
	value: t.array(t.tuple([t.string, NestableContent])),
})
export type GroupItemContent = t.TypeOf<typeof GroupItemContent>

const itemLegacyReader = t.array(t.tuple([t.string, t.unknown]))
type GroupItemLegacy = t.TypeOf<typeof itemLegacyReader>

export const GroupItemLegacy = (ctx: LegacyContentCtx) => {
	return new t.Type<GroupItemContent, WithTypes<GroupItemLegacy>>(
		"GroupItemLegacy",
		(u): u is GroupItemContent =>
			hasContentType(u) && u.__TYPE__ === GroupItemContentType,
		(u) => {
			const parsed = pipe(
				itemLegacyReader.decode(u),
				either.map((items) => {
					const parsedItems = items.reduce<Array<[string, NestableContent]>>(
						(acc, [itemKey, itemValue]) => {
							const itemCtx = getFieldCtx(itemKey, ctx)
							const result = NestableLegacy(itemCtx).decode(itemValue)
							if (!result) return acc

							if (isLeft(result)) return acc
							return [...acc, [itemKey, result.right]]
						},
						[],
					)

					return {
						value: parsedItems,
						__TYPE__: GroupItemContentType,
					}
				}),
			)
			return parsed
		},
		(item) => {
			return item.value.reduce<WithTypes<GroupItemLegacy>>(
				(acc, [key, value]) => {
					const itemCtx = getFieldCtx(key, ctx)
					const encoded = NestableLegacy(itemCtx).encode(value)
					if (!encoded) return acc

					return {
						content: [...acc.content, [key, encoded.content]],
						types: { ...acc.types, ...encoded.types },
					}
				},
				{ content: [], types: {} },
			)
		},
	)
}

type GroupLegacy = Array<GroupItemLegacy>
export const GroupLegacy = (ctx: LegacyContentCtx) => {
	const codec = t.array(GroupItemLegacy(ctx))

	return new t.Type<GroupContent, WithTypes<GroupLegacy>, unknown>(
		"GroupLegacy",
		isGroupContent,
		(items) => {
			return pipe(
				codec.decode(items),
				either.map((parsedItems) => {
					return {
						value: parsedItems,
						__TYPE__: GroupContentType,
					}
				}),
			)
		},
		(g: GroupContent) => {
			const res = codec.encode(g.value)

			return {
				content: res.map((block) => block.content),
				types: res.reduce<Record<string, FieldOrSliceType>>(
					(acc, block) => {
						return { ...acc, ...block.types }
					},
					{ [ctx.keyOfType]: "Group" },
				),
			}
		},
	)
}

export const GroupContentType = "GroupContentType" as const

export const isGroupContent = (u: unknown): u is GroupContent =>
	hasContentType(u) && u.__TYPE__ === GroupContentType

export const GroupContent = t.strict({
	__TYPE__: t.literal(GroupContentType),
	value: t.array(GroupItemContent),
})
export type GroupContent = t.TypeOf<typeof GroupContent>
