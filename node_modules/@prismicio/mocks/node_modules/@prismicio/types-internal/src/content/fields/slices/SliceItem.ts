import { either } from "fp-ts"
import { isLeft } from "fp-ts/lib/Either"
import { pipe } from "fp-ts/lib/function"
import * as t from "io-ts"

import { nullable } from "../../../validators/function"
import {
	getFieldCtx,
	LegacyContentCtx,
	WithTypes,
} from "../../LegacyContentCtx"
import { SliceContent, SliceLegacy } from "./Slice"
import { isCompositeSliceContent } from "./Slice/CompositeSliceContent"
import { isSharedSliceContent } from "./Slice/SharedSliceContent"
import { isSimpleSliceContent } from "./Slice/SimpleSliceContent"

export const SliceItemContent = t.type({
	key: t.string,
	name: t.string,
	maybeLabel: t.union([t.string, t.undefined]),
	widget: SliceContent,
})
export type SliceItemContent = t.TypeOf<typeof SliceItemContent>

const itemLegacyReader = t.exact(
	t.intersection([
		t.type({
			key: t.string,
			value: t.unknown,
		}),
		t.partial({
			label: nullable(t.string),
		}),
	]),
)

type SliceItemLegacy = t.TypeOf<typeof itemLegacyReader>

export const SlicesItemLegacy = (ctx: LegacyContentCtx) => {
	return new t.Type<SliceItemContent, WithTypes<SliceItemLegacy>, unknown>(
		"SlicesItemLegacy",
		(u): u is SliceItemContent => (
			isSharedSliceContent((u as SliceItemContent).widget),
			isCompositeSliceContent((u as SliceItemContent).widget),
			isSimpleSliceContent((u as SliceItemContent).widget)
		),
		(sliceItem, context) => {
			return pipe(
				itemLegacyReader.decode(sliceItem),
				either.chain((parsedSlice) => {
					const stopIdx = parsedSlice.key.indexOf("$")
					const sliceName = parsedSlice.key.substring(
						0,
						stopIdx > 0 ? stopIdx : undefined,
					)
					const itemCtx = getFieldCtx(sliceName, ctx)
					const item = SliceLegacy(itemCtx).decode(parsedSlice.value)
					if (!item || isLeft(item)) return t.failure(sliceItem, context)

					return t.success({
						key: parsedSlice.key,
						name: sliceName,
						maybeLabel: parsedSlice.label ?? undefined,
						widget: item.right,
					})
				}),
			)
		},
		(sItem: SliceItemContent) => {
			const itemCtx = getFieldCtx(sItem.name, ctx)
			const result = SliceLegacy(itemCtx).encode(sItem.widget)

			return {
				content: {
					key: sItem.key,
					label: sItem.maybeLabel,
					value: result?.content || {},
				},
				types: result?.types || {},
			}
		},
	)
}
