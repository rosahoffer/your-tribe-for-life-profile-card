"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlicesContent = exports.SlicesLegacy = exports.isSlicesContent = exports.SlicesContentType = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const function_1 = require("fp-ts/lib/function");
const t = tslib_1.__importStar(require("io-ts"));
const utils_1 = require("../../utils");
const SliceItem_1 = require("./SliceItem");
exports.SlicesContentType = "SliceContentType";
const isSlicesContent = (u) => (0, utils_1.hasContentType)(u) && u.__TYPE__ === exports.SlicesContentType;
exports.isSlicesContent = isSlicesContent;
const SlicesLegacy = (ctx) => {
    const codec = t.array((0, SliceItem_1.SlicesItemLegacy)(ctx));
    return new t.Type("SlicesLegacy", exports.isSlicesContent, (items) => {
        return (0, function_1.pipe)(codec.decode(items), fp_ts_1.either.map((parsedSlices) => {
            return {
                __TYPE__: exports.SlicesContentType,
                value: parsedSlices,
            };
        }));
    }, (s) => {
        const result = codec.encode(s.value);
        return {
            content: result.map((s) => s.content),
            types: result.reduce((acc, s) => ({ ...acc, ...s.types }), { [ctx.keyOfType]: "Slices" }),
        };
    });
};
exports.SlicesLegacy = SlicesLegacy;
exports.SlicesContent = t.type({
    __TYPE__: t.literal(exports.SlicesContentType),
    value: t.array(SliceItem_1.SliceItemContent),
});
