"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentLegacy = exports.Document = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const Either_1 = require("fp-ts/lib/Either");
const function_1 = require("fp-ts/lib/function");
const t = tslib_1.__importStar(require("io-ts"));
const common_1 = require("../common");
const fields_1 = require("./fields");
const LegacyContentCtx_1 = require("./LegacyContentCtx");
exports.Document = t.record(common_1.WidgetKey, fields_1.WidgetContent);
const legacyDocReader = t.record(common_1.WidgetKey, t.unknown);
const DocumentLegacyCodec = (allTypes) => {
    return new t.Type("Document", (u) => !!u && typeof u === "object", (doc) => {
        return (0, function_1.pipe)(legacyDocReader.decode(doc), fp_ts_1.either.map((parsedDoc) => {
            return Object.entries(parsedDoc).reduce((acc, [widgetKey, widgetValue]) => {
                const widgetCtx = (0, LegacyContentCtx_1.defaultCtx)(widgetKey, allTypes);
                const parsedW = (0, fields_1.WidgetLegacy)(widgetCtx).decode(widgetValue);
                if (!parsedW || (0, Either_1.isLeft)(parsedW))
                    return acc;
                return { ...acc, [widgetKey]: parsedW.right };
            }, {});
        }));
    }, (g) => {
        return Object.entries(g).reduce((acc, [key, value]) => {
            const widgetCtx = (0, LegacyContentCtx_1.defaultCtx)(key, allTypes);
            const result = (0, fields_1.WidgetLegacy)(widgetCtx).encode(value);
            if (!result)
                return acc;
            return {
                content: { ...acc.content, [key]: result.content },
                types: { ...acc.types, ...result.types },
            };
        }, { content: {}, types: {} });
    });
};
function extractMetadata(data) {
    const fields = Object.entries(data);
    const { types, widgets } = fields.reduce((acc, [k, v]) => {
        if (k.endsWith("_TYPE")) {
            const decodedValue = LegacyContentCtx_1.FieldOrSliceType.decode(v);
            if ((0, Either_1.isRight)(decodedValue)) {
                return {
                    ...acc,
                    types: acc.types.set(k.substring(0, k.length - 5), decodedValue.right),
                };
            }
        }
        if (!k.endsWith("_POSITION") && !k.endsWith("_TYPE")) {
            return {
                ...acc,
                widgets: {
                    ...acc.widgets,
                    [k]: v,
                },
            };
        }
        return acc;
    }, {
        types: new Map(),
        widgets: {},
    });
    const slugs = data["slugs_INTERNAL"] || [];
    const uid = data["uid"];
    return {
        widgets,
        types,
        uid,
        slugs,
    };
}
function parseLegacyDocument(legacyDoc) {
    const result = (0, function_1.pipe)(
    // ensure it's the right document format first
    t.record(common_1.WidgetKey, t.unknown).decode(legacyDoc), fp_ts_1.either.chain((doc) => {
        // extract all metadata, meaning all _TYPES keys from legacy format + the widgets as unknown
        const { types, widgets } = extractMetadata(doc);
        // parse the actual widgets
        return DocumentLegacyCodec(types).decode(widgets);
    }));
    return (0, Either_1.isLeft)(result) ? undefined : result.right;
}
function encodeToLegacyDocument(document) {
    const encoded = DocumentLegacyCodec().encode(document);
    return { ...encoded.content, ...encoded.types };
}
exports.DocumentLegacy = {
    _codec: DocumentLegacyCodec,
    extractMetadata,
    parse: parseLegacyDocument,
    encode: encodeToLegacyDocument,
};
