"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addType = exports.isEmpty = exports.objectToMap = exports.grouped = exports.formatDate = exports.formatDateTime = exports.filterDouble = exports.refineType = exports.nullable = void 0;
const tslib_1 = require("tslib");
const fp_ts_1 = require("fp-ts");
const function_1 = require("fp-ts/function");
const t = tslib_1.__importStar(require("io-ts"));
const mapOutput_1 = require("io-ts-types/mapOutput");
function nullable(c) {
    return t.union([c, t.null, t.undefined]);
}
exports.nullable = nullable;
function refineType(type, newName, pred) {
    return new t.Type(newName, type.is, (u, c) => (0, function_1.pipe)(type.validate(u, c), fp_ts_1.either.chain((v) => (pred(v) ? t.success(v) : t.failure(u, c)))), type.encode);
}
exports.refineType = refineType;
function filterDouble(value) {
    if (value === "") {
        return null;
    }
    const result = Number(value);
    return Number.isNaN(result) ? null : result;
}
exports.filterDouble = filterDouble;
function formatDateTime(date) {
    return date.toISOString().replace(/\.\d{3}Z$/, "+0000");
}
exports.formatDateTime = formatDateTime;
function formatDate(date) {
    return date.toISOString().replace(/T.*/, "");
}
exports.formatDate = formatDate;
function grouped(array, n) {
    return array.reduce((acc, curr, idx) => {
        if (idx % n === 0) {
            acc.push([curr]);
        }
        else {
            /* eslint-disable  @typescript-eslint/no-non-null-assertion */
            acc[Math.floor(idx / n)].push(curr);
        }
        return acc;
    }, new Array());
}
exports.grouped = grouped;
function objectToMap(object) {
    return new Map(Object.entries(object));
}
exports.objectToMap = objectToMap;
function isEmpty(obj) {
    for (const _x in obj) {
        return false;
    }
    return true;
}
exports.isEmpty = isEmpty;
function addType(codec, t) {
    return (0, mapOutput_1.mapOutput)(codec, (o) => ({ ...o, __TYPE__: t }));
}
exports.addType = addType;
